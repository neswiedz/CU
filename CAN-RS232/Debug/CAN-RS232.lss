
CAN-RS232.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000098  00800100  00000f26  00000fba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f26  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000003ec  00800198  00800198  00001052  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001052  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000260  00000000  00000000  00001082  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001bde  00000000  00000000  000012e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a40  00000000  00000000  00002ec0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000dc8  00000000  00000000  00003900  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000006e0  00000000  00000000  000046c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000850  00000000  00000000  00004da8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001914  00000000  00000000  000055f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001f0  00000000  00000000  00006f0c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
   4:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
   8:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
   c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  10:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  14:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  18:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  1c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  20:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  24:	0c 94 75 03 	jmp	0x6ea	; 0x6ea <__vector_9>
  28:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  2c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  30:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  34:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  38:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  3c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  40:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  44:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  48:	0c 94 d2 01 	jmp	0x3a4	; 0x3a4 <__vector_18>
  4c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  50:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  54:	0c 94 0f 01 	jmp	0x21e	; 0x21e <__vector_21>
  58:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  5c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  60:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  64:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  68:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  6c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  70:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  74:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  78:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  7c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  80:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  84:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  88:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  8c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
  90:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	e6 e2       	ldi	r30, 0x26	; 38
  a8:	ff e0       	ldi	r31, 0x0F	; 15
  aa:	00 e0       	ldi	r16, 0x00	; 0
  ac:	0b bf       	out	0x3b, r16	; 59
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <__do_copy_data+0x14>
  b0:	07 90       	elpm	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	a8 39       	cpi	r26, 0x98	; 152
  b6:	b1 07       	cpc	r27, r17
  b8:	d9 f7       	brne	.-10     	; 0xb0 <__do_copy_data+0x10>

000000ba <__do_clear_bss>:
  ba:	25 e0       	ldi	r18, 0x05	; 5
  bc:	a8 e9       	ldi	r26, 0x98	; 152
  be:	b1 e0       	ldi	r27, 0x01	; 1
  c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
  c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
  c4:	a4 38       	cpi	r26, 0x84	; 132
  c6:	b2 07       	cpc	r27, r18
  c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
  ca:	0e 94 bc 00 	call	0x178	; 0x178 <main>
  ce:	0c 94 91 07 	jmp	0xf22	; 0xf22 <_exit>

000000d2 <__bad_interrupt>:
  d2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d6 <uart_int_init>:
						uart_state = STATE_READY;
					}
				}			
				break;
			case STATE_ADDRESS:
				if (uart_timeout_check(rtc_milliseconds)) {
  d6:	e1 ec       	ldi	r30, 0xC1	; 193
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	80 81       	ld	r24, Z
  dc:	80 68       	ori	r24, 0x80	; 128
  de:	80 83       	st	Z, r24
  e0:	89 ea       	ldi	r24, 0xA9	; 169
					uart_state = STATE_READY;
				} else {
					if (uart_msg_address_length == 0x00) {
  e2:	92 e0       	ldi	r25, 0x02	; 2
  e4:	90 93 a7 02 	sts	0x02A7, r25
  e8:	80 93 a6 02 	sts	0x02A6, r24
						uart_msg_address = rx_data << 8;
  ec:	90 93 9d 01 	sts	0x019D, r25
  f0:	80 93 9c 01 	sts	0x019C, r24
						uart_msg_address_length++;
  f4:	08 95       	ret

000000f6 <app_init>:
  f6:	f8 94       	cli
  f8:	80 e8       	ldi	r24, 0x80	; 128
					} else if(uart_msg_address_length == 0x01) {
  fa:	80 93 61 00 	sts	0x0061, r24
  fe:	10 92 61 00 	sts	0x0061, r1
						uart_msg_address |= rx_data;
 102:	0e 94 16 03 	call	0x62c	; 0x62c <led_init>
 106:	40 e0       	ldi	r20, 0x00	; 0
 108:	52 ec       	ldi	r21, 0xC2	; 194
 10a:	61 e0       	ldi	r22, 0x01	; 1
 10c:	70 e0       	ldi	r23, 0x00	; 0
 10e:	83 e0       	ldi	r24, 0x03	; 3
 110:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_init>
						uart_msg_address_length++;
 114:	0e 94 6b 00 	call	0xd6	; 0xd6 <uart_int_init>
						uart_state = STATE_TOKEN;
 118:	0e 94 26 03 	call	0x64c	; 0x64c <rtc_int_init>
						uart_state = STATE_READY;
					}
				}
				break;			
			case STATE_TOKEN:
				if (uart_timeout_check(rtc_milliseconds)) {
 11c:	85 e0       	ldi	r24, 0x05	; 5
 11e:	0e 94 4b 01 	call	0x296	; 0x296 <initCAN>
 122:	88 23       	and	r24, r24
 124:	29 f0       	breq	.+10     	; 0x130 <app_init+0x3a>
 126:	0e 94 bf 01 	call	0x37e	; 0x37e <configRX>
 12a:	78 94       	sei
					uart_state = STATE_READY;
				} else {
					if (rx_data == MESSAGE_TOKEN)  {
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	08 95       	ret
						uart_msg_size = MESSAGE_DATA_SIZE;
 130:	89 e4       	ldi	r24, 0x49	; 73
 132:	8f 93       	push	r24
 134:	84 e5       	ldi	r24, 0x54	; 84
						uart_state = STATE_DATA;
 136:	8f 93       	push	r24
 138:	0e 94 19 05 	call	0xa32	; 0xa32 <uart_mini_printf>
						uart_state = STATE_READY;
					}						
				}
				break;
			case STATE_DATA:
				if (uart_timeout_check(rtc_milliseconds)) {
 13c:	0f 90       	pop	r0
 13e:	0f 90       	pop	r0
 140:	80 e0       	ldi	r24, 0x00	; 0
 142:	08 95       	ret

00000144 <uart_int_getchar_int>:
 144:	f8 94       	cli
 146:	e0 91 a6 02 	lds	r30, 0x02A6
					uart_state = STATE_READY;
				} else {
					*uart_rx_pntr++ = rx_data;
 14a:	f0 91 a7 02 	lds	r31, 0x02A7
 14e:	80 91 c6 00 	lds	r24, 0x00C6
 152:	80 83       	st	Z, r24
 154:	80 91 a6 02 	lds	r24, 0x02A6
 158:	90 91 a7 02 	lds	r25, 0x02A7
 15c:	23 e0       	ldi	r18, 0x03	; 3
 15e:	80 37       	cpi	r24, 0x70	; 112
					--uart_msg_size;
 160:	92 07       	cpc	r25, r18
 162:	10 f4       	brcc	.+4      	; 0x168 <uart_int_getchar_int+0x24>
 164:	01 96       	adiw	r24, 0x01	; 1
 166:	02 c0       	rjmp	.+4      	; 0x16c <uart_int_getchar_int+0x28>
 168:	89 ea       	ldi	r24, 0xA9	; 169
					if (uart_msg_size == 0)
 16a:	92 e0       	ldi	r25, 0x02	; 2
 16c:	90 93 a7 02 	sts	0x02A7, r25
					{
						uart_state = STATE_CS;
 170:	80 93 a6 02 	sts	0x02A6, r24
					}				
				}
				break;
			case STATE_CS:
				if (uart_timeout_check(rtc_milliseconds)) {
 174:	78 94       	sei
 176:	08 95       	ret

00000178 <main>:
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	0e 94 7b 00 	call	0xf6	; 0xf6 <app_init>
 180:	88 23       	and	r24, r24
					uart_state = STATE_READY;
				} else {
					if (rx_data == uart_msg_cs) {
 182:	09 f4       	brne	.+2      	; 0x186 <main+0xe>
 184:	47 c0       	rjmp	.+142    	; 0x214 <main+0x9c>
 186:	80 e0       	ldi	r24, 0x00	; 0
 188:	91 e0       	ldi	r25, 0x01	; 1
						message_buffor[message_pntr].address = uart_msg_address;
						for (i=0; i<MESSAGE_DATA_SIZE; i++) {
							message_buffor[message_pntr].data[i] = uart_rx_buffer[i]; 
						} 
					}
					uart_state = STATE_READY;
 18a:	9f 93       	push	r25
 18c:	8f 93       	push	r24
 18e:	0e 94 19 05 	call	0xa32	; 0xa32 <uart_mini_printf>
			case STATE_CS:
				if (uart_timeout_check(rtc_milliseconds)) {
					uart_state = STATE_READY;
				} else {
					if (rx_data == uart_msg_cs) {
						message_pntr++;
 192:	c4 e3       	ldi	r28, 0x34	; 52
 194:	d1 e0       	ldi	r29, 0x01	; 1
 196:	df 93       	push	r29
 198:	cf 93       	push	r28
						if (message_pntr>=MESSAGE_BUF_SIZE) {
 19a:	0e 94 19 05 	call	0xa32	; 0xa32 <uart_mini_printf>
 19e:	86 e6       	ldi	r24, 0x66	; 102
			case STATE_CS:
				if (uart_timeout_check(rtc_milliseconds)) {
					uart_state = STATE_READY;
				} else {
					if (rx_data == uart_msg_cs) {
						message_pntr++;
 1a0:	91 e0       	ldi	r25, 0x01	; 1
 1a2:	9f 93       	push	r25
 1a4:	8f 93       	push	r24
 1a6:	0e 94 19 05 	call	0xa32	; 0xa32 <uart_mini_printf>
						if (message_pntr>=MESSAGE_BUF_SIZE) {
							message_pntr=0;
 1aa:	df 93       	push	r29
 1ac:	cf 93       	push	r28
 1ae:	0e 94 19 05 	call	0xa32	; 0xa32 <uart_mini_printf>
						}
						message_buffor[message_pntr].handle = MESSAGE_UART_IN;
 1b2:	82 e0       	ldi	r24, 0x02	; 2
 1b4:	91 e0       	ldi	r25, 0x01	; 1
 1b6:	9f 93       	push	r25
 1b8:	8f 93       	push	r24
 1ba:	0e 94 19 05 	call	0xa32	; 0xa32 <uart_mini_printf>
 1be:	10 92 a2 02 	sts	0x02A2, r1
 1c2:	10 92 a3 02 	sts	0x02A3, r1
 1c6:	10 92 a4 02 	sts	0x02A4, r1
 1ca:	10 92 a5 02 	sts	0x02A5, r1
						message_buffor[message_pntr].procedure = uart_msg_procedure;
 1ce:	10 92 9b 01 	sts	0x019B, r1
 1d2:	10 92 9a 01 	sts	0x019A, r1
 1d6:	e9 e8       	ldi	r30, 0x89	; 137
 1d8:	f4 e0       	ldi	r31, 0x04	; 4
						message_buffor[message_pntr].address = uart_msg_address;
 1da:	8d b7       	in	r24, 0x3d	; 61
 1dc:	9e b7       	in	r25, 0x3e	; 62
 1de:	0a 96       	adiw	r24, 0x0a	; 10
 1e0:	0f b6       	in	r0, 0x3f	; 63
 1e2:	f8 94       	cli
 1e4:	9e bf       	out	0x3e, r25	; 62
 1e6:	0f be       	out	0x3f, r0	; 63
 1e8:	8d bf       	out	0x3d, r24	; 61
						for (i=0; i<MESSAGE_DATA_SIZE; i++) {
 1ea:	11 92       	st	Z+, r1
 1ec:	11 92       	st	Z+, r1
							message_buffor[message_pntr].data[i] = uart_rx_buffer[i]; 
 1ee:	11 92       	st	Z+, r1
 1f0:	11 92       	st	Z+, r1
 1f2:	94 e0       	ldi	r25, 0x04	; 4
 1f4:	e1 3b       	cpi	r30, 0xB1	; 177
 1f6:	f9 07       	cpc	r31, r25
							message_pntr=0;
						}
						message_buffor[message_pntr].handle = MESSAGE_UART_IN;
						message_buffor[message_pntr].procedure = uart_msg_procedure;
						message_buffor[message_pntr].address = uart_msg_address;
						for (i=0; i<MESSAGE_DATA_SIZE; i++) {
 1f8:	c1 f7       	brne	.-16     	; 0x1ea <main+0x72>
 1fa:	0e 94 0e 03 	call	0x61c	; 0x61c <led_g_on>
 1fe:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <led_y_on>
					}
					uart_state = STATE_READY;
				}
				break;				
		}
		uart_msg_cs ^= rx_data;
 202:	0e 94 ad 02 	call	0x55a	; 0x55a <OW_reset_pulse>
 206:	89 2b       	or	r24, r25
 208:	11 f0       	breq	.+4      	; 0x20e <main+0x96>
 20a:	0e 94 04 03 	call	0x608	; 0x608 <led_y_toogle>
	}		
}
 20e:	0e 94 1c 03 	call	0x638	; 0x638 <led_g_toogle>
 212:	fd cf       	rjmp	.-6      	; 0x20e <main+0x96>
				uart_mini_printf("%d, %d\n",taba[8],taba[9]);
			}
			*/
		}
	}	
}
 214:	80 e0       	ldi	r24, 0x00	; 0
 216:	90 e0       	ldi	r25, 0x00	; 0
 218:	df 91       	pop	r29
 21a:	cf 91       	pop	r28
 21c:	08 95       	ret

0000021e <__vector_21>:


//_____ M A C R O S ____________________________________________________________

ISR(USART0_RX_vect) {
 21e:	1f 92       	push	r1
 220:	0f 92       	push	r0
 222:	0f b6       	in	r0, 0x3f	; 63
 224:	0f 92       	push	r0
 226:	11 24       	eor	r1, r1
 228:	0b b6       	in	r0, 0x3b	; 59
 22a:	0f 92       	push	r0
 22c:	2f 93       	push	r18
 22e:	3f 93       	push	r19
 230:	4f 93       	push	r20
 232:	5f 93       	push	r21
 234:	6f 93       	push	r22
 236:	7f 93       	push	r23
 238:	8f 93       	push	r24
 23a:	9f 93       	push	r25
 23c:	af 93       	push	r26
 23e:	bf 93       	push	r27
 240:	ef 93       	push	r30
 242:	ff 93       	push	r31
   uart_int_getchar_int();
 244:	0e 94 a2 00 	call	0x144	; 0x144 <uart_int_getchar_int>
 248:	ff 91       	pop	r31
 24a:	ef 91       	pop	r30
 24c:	bf 91       	pop	r27
 24e:	af 91       	pop	r26
 250:	9f 91       	pop	r25
 252:	8f 91       	pop	r24
 254:	7f 91       	pop	r23
 256:	6f 91       	pop	r22
 258:	5f 91       	pop	r21
 25a:	4f 91       	pop	r20
 25c:	3f 91       	pop	r19
 25e:	2f 91       	pop	r18
 260:	0f 90       	pop	r0
 262:	0b be       	out	0x3b, r0	; 59
 264:	0f 90       	pop	r0
 266:	0f be       	out	0x3f, r0	; 63
 268:	0f 90       	pop	r0
 26a:	1f 90       	pop	r1
 26c:	18 95       	reti

0000026e <getmob>:
// suchen des MOb in dem die Nachricht ist
uint8_t getmob( uint32_t bitmask) 
{
  uint8_t mob;

  if( bitmask==0) return NOMOB;
 26e:	61 15       	cp	r22, r1
 270:	71 05       	cpc	r23, r1
 272:	81 05       	cpc	r24, r1
 274:	91 05       	cpc	r25, r1
 276:	59 f0       	breq	.+22     	; 0x28e <getmob+0x20>
 278:	20 e0       	ldi	r18, 0x00	; 0

  for( mob=0; (bitmask & 0x01)==0; bitmask >>= 1, ++mob);
 27a:	60 fd       	sbrc	r22, 0
 27c:	06 c0       	rjmp	.+12     	; 0x28a <getmob+0x1c>
 27e:	96 95       	lsr	r25
 280:	87 95       	ror	r24
 282:	77 95       	ror	r23
 284:	67 95       	ror	r22
 286:	2f 5f       	subi	r18, 0xFF	; 255
 288:	f8 cf       	rjmp	.-16     	; 0x27a <getmob+0xc>

  //  security check
  if ( mob > 14 ) return NOMOB;
 28a:	2f 30       	cpi	r18, 0x0F	; 15
 28c:	10 f0       	brcs	.+4      	; 0x292 <getmob+0x24>
// suchen des MOb in dem die Nachricht ist
uint8_t getmob( uint32_t bitmask) 
{
  uint8_t mob;

  if( bitmask==0) return NOMOB;
 28e:	8f ef       	ldi	r24, 0xFF	; 255
 290:	08 95       	ret
 292:	82 2f       	mov	r24, r18
  for( mob=0; (bitmask & 0x01)==0; bitmask >>= 1, ++mob);

  //  security check
  if ( mob > 14 ) return NOMOB;
    else return mob;
}     
 294:	08 95       	ret

00000296 <initCAN>:

// initializes CAN interface
// Funktion zum Initialisieren
Bool initCAN( uint8_t bitrate )
{
  CAN_DDR |= _BV(CAN_TX);
 296:	55 9a       	sbi	0x0a, 5	; 10
  CAN_DDR &= ~_BV(CAN_RX);
 298:	56 98       	cbi	0x0a, 6	; 10

  //  security check
  if (bitrate >= 8) return false;
 29a:	88 30       	cpi	r24, 0x08	; 8
 29c:	08 f0       	brcs	.+2      	; 0x2a0 <initCAN+0xa>
 29e:	6b c0       	rjmp	.+214    	; 0x376 <initCAN+0xe0>
  
  //  number of the MOb
  uint8_t mob;

  CANGCON |= (1<<SWRES);		// reset the CAN controller
 2a0:	80 91 d8 00 	lds	r24, 0x00D8
 2a4:	81 60       	ori	r24, 0x01	; 1
 2a6:	80 93 d8 00 	sts	0x00D8, r24
  
  CANGCON = 0x00;				// reset the general control register (CONFIG mode)
 2aa:	10 92 d8 00 	sts	0x00D8, r1

  // reset the interrupt registers
  CANSIT2 = 0x00;
 2ae:	10 92 e0 00 	sts	0x00E0, r1
  CANSIT1 = 0x00;
 2b2:	10 92 e1 00 	sts	0x00E1, r1
  CANGIT  = 0x00;
 2b6:	10 92 da 00 	sts	0x00DA, r1
  CANGIE  = 0x00;
 2ba:	10 92 db 00 	sts	0x00DB, r1
  CANEN1  = 0x00;
 2be:	10 92 dd 00 	sts	0x00DD, r1
  CANEN2  = 0x00;
 2c2:	10 92 dc 00 	sts	0x00DC, r1
  CANIE1  = 0x00;
 2c6:	10 92 df 00 	sts	0x00DF, r1
  CANIE2  = 0x00;
 2ca:	10 92 de 00 	sts	0x00DE, r1

  // set auto inc to Data Buffer Index (DBI)
  CANPAGE &= ~(1<<AINC);
 2ce:	80 91 ed 00 	lds	r24, 0x00ED
 2d2:	87 7f       	andi	r24, 0xF7	; 247
 2d4:	80 93 ed 00 	sts	0x00ED, r24

  // set all MObs to 0
  for (mob = 0; mob < NR_MOBS; mob++)
 2d8:	80 e0       	ldi	r24, 0x00	; 0
  {
    CANPAGE  = (mob << 4);
 2da:	98 2f       	mov	r25, r24
 2dc:	92 95       	swap	r25
 2de:	90 7f       	andi	r25, 0xF0	; 240
 2e0:	90 93 ed 00 	sts	0x00ED, r25
	CANIDT1 = 0x00;  //  reset ID-Tag
 2e4:	10 92 f3 00 	sts	0x00F3, r1
	CANIDT2 = 0x00;
 2e8:	10 92 f2 00 	sts	0x00F2, r1
	CANIDT3 = 0x00;
 2ec:	10 92 f1 00 	sts	0x00F1, r1
	CANIDT4 = 0x00;
 2f0:	10 92 f0 00 	sts	0x00F0, r1

	CANIDM1 = 0x00;  //  reset ID-Mask
 2f4:	10 92 f7 00 	sts	0x00F7, r1
	CANIDM2 = 0x00;
 2f8:	10 92 f6 00 	sts	0x00F6, r1
	CANIDM3 = 0x00;
 2fc:	10 92 f5 00 	sts	0x00F5, r1
	CANIDM4 = 0x00;
 300:	10 92 f4 00 	sts	0x00F4, r1

    CANSTMOB = 0x00;  //  reset MOb status
 304:	10 92 ee 00 	sts	0x00EE, r1
    CANCDMOB = 0x00;  //  disable MOb
 308:	10 92 ef 00 	sts	0x00EF, r1

  // set auto inc to Data Buffer Index (DBI)
  CANPAGE &= ~(1<<AINC);

  // set all MObs to 0
  for (mob = 0; mob < NR_MOBS; mob++)
 30c:	8f 5f       	subi	r24, 0xFF	; 255
 30e:	8f 30       	cpi	r24, 0x0F	; 15
 310:	21 f7       	brne	.-56     	; 0x2da <initCAN+0x44>
    CANSTMOB = 0x00;  //  reset MOb status
    CANCDMOB = 0x00;  //  disable MOb
  }

  // HAPCAN
  CANBT1 = 0x0E;
 312:	8e e0       	ldi	r24, 0x0E	; 14
 314:	80 93 e2 00 	sts	0x00E2, r24
  CANBT2 = 0x2C;
 318:	8c e2       	ldi	r24, 0x2C	; 44
 31a:	80 93 e3 00 	sts	0x00E3, r24
  CANBT3 = 0x37;
 31e:	87 e3       	ldi	r24, 0x37	; 55
 320:	80 93 e4 00 	sts	0x00E4, r24
  // set config to MObs 1 and 2
  // MOb 1 soll empfangen
  // MOb 2 soll senden
  for (mob = 1; mob < 3; mob++)
  {
    CANPAGE  = (mob << 4);
 324:	80 e1       	ldi	r24, 0x10	; 16
 326:	80 93 ed 00 	sts	0x00ED, r24
	CANSTMOB = 0x00;  //  reset MOb status
 32a:	10 92 ee 00 	sts	0x00EE, r1
	switch (mob)
	{
      case 1:
	    CANCDMOB = 0x80;  //  RX
 32e:	80 e8       	ldi	r24, 0x80	; 128
 330:	80 93 ef 00 	sts	0x00EF, r24
	  	CANIDT1  = 0x00;  //  set ID-Tag
 334:	10 92 f3 00 	sts	0x00F3, r1
	    CANIDT2  = 0x00;
 338:	10 92 f2 00 	sts	0x00F2, r1

	    CANIDM1  = 0x00;  //  set ID-Mask, receive all
 33c:	10 92 f7 00 	sts	0x00F7, r1
	    CANIDM2  = 0x00;
 340:	10 92 f6 00 	sts	0x00F6, r1
  // set config to MObs 1 and 2
  // MOb 1 soll empfangen
  // MOb 2 soll senden
  for (mob = 1; mob < 3; mob++)
  {
    CANPAGE  = (mob << 4);
 344:	80 e2       	ldi	r24, 0x20	; 32
 346:	80 93 ed 00 	sts	0x00ED, r24
	CANSTMOB = 0x00;  //  reset MOb status
 34a:	10 92 ee 00 	sts	0x00EE, r1
	    CANIDM1  = 0x00;  //  set ID-Mask, receive all
	    CANIDM2  = 0x00;
        break;

	  case 2:
	  	CANIDT1  = 0x00;  //  set ID-Tag
 34e:	10 92 f3 00 	sts	0x00F3, r1
	    CANIDT2  = 0x00;
 352:	10 92 f2 00 	sts	0x00F2, r1
	    return false;
	}
  }

  //  Enable all required interrupts
  CANGIE  = 0xB0;  // ENIT, ENRX, ENTX
 356:	80 eb       	ldi	r24, 0xB0	; 176
 358:	80 93 db 00 	sts	0x00DB, r24
  CANIE2  = 0x06;  // MOb 1, MOb 2 aktivieren
 35c:	86 e0       	ldi	r24, 0x06	; 6
 35e:	80 93 de 00 	sts	0x00DE, r24
    
  //  switch CAN on   
  CANGCON |= (1<<ENASTB);
 362:	80 91 d8 00 	lds	r24, 0x00D8
 366:	82 60       	ori	r24, 0x02	; 2
 368:	80 93 d8 00 	sts	0x00D8, r24
  	
  //  wait for EnableFlag
  while (!(CANGSTA & (1<<ENFG))); 
 36c:	80 91 d9 00 	lds	r24, 0x00D9
 370:	82 ff       	sbrs	r24, 2
 372:	fc cf       	rjmp	.-8      	; 0x36c <initCAN+0xd6>
 374:	02 c0       	rjmp	.+4      	; 0x37a <initCAN+0xe4>
{
  CAN_DDR |= _BV(CAN_TX);
  CAN_DDR &= ~_BV(CAN_RX);

  //  security check
  if (bitrate >= 8) return false;
 376:	80 e0       	ldi	r24, 0x00	; 0
 378:	08 95       	ret
  CANGCON |= (1<<ENASTB);
  	
  //  wait for EnableFlag
  while (!(CANGSTA & (1<<ENFG))); 
  
  return true;
 37a:	81 e0       	ldi	r24, 0x01	; 1
}
 37c:	08 95       	ret

0000037e <configRX>:
  uint8_t mob;

  // receive in this MOb
  mob = 1;

  CANPAGE = (mob<<4);  // rotate 4 bits left	
 37e:	80 e1       	ldi	r24, 0x10	; 16
 380:	80 93 ed 00 	sts	0x00ED, r24

  // define the IDTags to get only one ID (Filter)
  CANIDT4 = 0;		
 384:	10 92 f0 00 	sts	0x00F0, r1
  CANIDT3 = 0;	
 388:	10 92 f1 00 	sts	0x00F1, r1
  CANIDT2 = 0;
 38c:	10 92 f2 00 	sts	0x00F2, r1
  CANIDT1 = 0;
 390:	10 92 f3 00 	sts	0x00F3, r1

  // define the IDMasks to activate the Tags (Maske)
  // 1 means filter, 0 means uncared

  CANIDM1  = 0x00;  //filter off, don't care
 394:	10 92 f7 00 	sts	0x00F7, r1
  CANIDM2  = 0x00;
 398:	10 92 f6 00 	sts	0x00F6, r1

  //  activate receiving messages with 11 bit id´s
  CANCDMOB = (1<<CONMOB1);
 39c:	80 e8       	ldi	r24, 0x80	; 128
 39e:	80 93 ef 00 	sts	0x00EF, r24
 3a2:	08 95       	ret

000003a4 <__vector_18>:
}

// interrupt service for CAN
SIGNAL(SIG_CAN_INTERRUPT1)
{
 3a4:	1f 92       	push	r1
 3a6:	0f 92       	push	r0
 3a8:	0f b6       	in	r0, 0x3f	; 63
 3aa:	0f 92       	push	r0
 3ac:	11 24       	eor	r1, r1
 3ae:	0b b6       	in	r0, 0x3b	; 59
 3b0:	0f 92       	push	r0
 3b2:	1f 93       	push	r17
 3b4:	2f 93       	push	r18
 3b6:	3f 93       	push	r19
 3b8:	4f 93       	push	r20
 3ba:	5f 93       	push	r21
 3bc:	6f 93       	push	r22
 3be:	7f 93       	push	r23
 3c0:	8f 93       	push	r24
 3c2:	9f 93       	push	r25
 3c4:	af 93       	push	r26
 3c6:	bf 93       	push	r27
 3c8:	ef 93       	push	r30
 3ca:	ff 93       	push	r31
 3cc:	cf 93       	push	r28
 3ce:	df 93       	push	r29
 3d0:	00 d0       	rcall	.+0      	; 0x3d2 <__vector_18+0x2e>
 3d2:	00 d0       	rcall	.+0      	; 0x3d4 <__vector_18+0x30>
 3d4:	cd b7       	in	r28, 0x3d	; 61
 3d6:	de b7       	in	r29, 0x3e	; 62
  // CAN_messageType recMsg; this is a global variable
  uint8_t save_canpage = CANPAGE;		//  actual CANPAGE
 3d8:	10 91 ed 00 	lds	r17, 0x00ED
  uint8_t readmodwrite;
  uint32_t identifier;
  CAN_messageType *recMsg;
  
  // check in which MOb the INT was initiated
  mob = getmob(CANSIT2 | (CANSIT1 << 8));
 3dc:	60 91 e0 00 	lds	r22, 0x00E0
 3e0:	80 91 e1 00 	lds	r24, 0x00E1
 3e4:	70 e0       	ldi	r23, 0x00	; 0
 3e6:	78 2b       	or	r23, r24
 3e8:	88 27       	eor	r24, r24
 3ea:	77 fd       	sbrc	r23, 7
 3ec:	80 95       	com	r24
 3ee:	98 2f       	mov	r25, r24
 3f0:	0e 94 37 01 	call	0x26e	; 0x26e <getmob>
	if( mob == NOMOB )   return;
 3f4:	8f 3f       	cpi	r24, 0xFF	; 255
 3f6:	09 f4       	brne	.+2      	; 0x3fa <__vector_18+0x56>
 3f8:	90 c0       	rjmp	.+288    	; 0x51a <__vector_18+0x176>

  // select concerned MOb page
  CANPAGE = (mob << 4);	
 3fa:	82 95       	swap	r24
 3fc:	80 7f       	andi	r24, 0xF0	; 240
 3fe:	80 93 ed 00 	sts	0x00ED, r24

  // Senden war erfolgreich
  if (CANSTMOB & (1<<TXOK))
 402:	80 91 ee 00 	lds	r24, 0x00EE
 406:	86 ff       	sbrs	r24, 6
 408:	06 c0       	rjmp	.+12     	; 0x416 <__vector_18+0x72>
  {
    readmodwrite = CANSTMOB;	 	
 40a:	80 91 ee 00 	lds	r24, 0x00EE
    readmodwrite &= ~(1<<TXOK);	//  reset INT reason
 40e:	8f 7b       	andi	r24, 0xBF	; 191
	CANSTMOB = readmodwrite;			
 410:	80 93 ee 00 	sts	0x00EE, r24
 414:	80 c0       	rjmp	.+256    	; 0x516 <__vector_18+0x172>
  }
  // Nachricht erfolgreich empfangen
  else if (CANSTMOB & (1<<RXOK))
 416:	80 91 ee 00 	lds	r24, 0x00EE
 41a:	85 ff       	sbrs	r24, 5
 41c:	7c c0       	rjmp	.+248    	; 0x516 <__vector_18+0x172>
  {
	if (can_rx_index < CAN_MAX_BUF_SIZE-1) {
 41e:	80 91 98 01 	lds	r24, 0x0198
 422:	83 31       	cpi	r24, 0x13	; 19
 424:	20 f4       	brcc	.+8      	; 0x42e <__vector_18+0x8a>
		can_rx_index++;
 426:	8f 5f       	subi	r24, 0xFF	; 255
 428:	80 93 98 01 	sts	0x0198, r24
 42c:	02 c0       	rjmp	.+4      	; 0x432 <__vector_18+0x8e>
	} else {
		can_rx_index = 0;
 42e:	10 92 98 01 	sts	0x0198, r1
	}		
		  
    recMsg = &can_rx_buffer[can_rx_index];
 432:	e0 91 98 01 	lds	r30, 0x0198
 436:	2e e0       	ldi	r18, 0x0E	; 14
 438:	e2 9f       	mul	r30, r18
 43a:	f0 01       	movw	r30, r0
 43c:	11 24       	eor	r1, r1
 43e:	ef 58       	subi	r30, 0x8F	; 143
 440:	fc 4f       	sbci	r31, 0xFC	; 252
	
	if (CANCDMOB & (1<<IDE))
 442:	80 91 ef 00 	lds	r24, 0x00EF
 446:	84 ff       	sbrs	r24, 4
 448:	2e c0       	rjmp	.+92     	; 0x4a6 <__vector_18+0x102>
		*((U8 *)(&(identifier))+3) =  CANIDT1>>3              ; 
		*((U8 *)(&(identifier))+2) = (CANIDT2>>3)+(CANIDT1<<5); 
		*((U8 *)(&(identifier))+1) = (CANIDT3>>3)+(CANIDT2<<5); 
		*((U8 *)(&(identifier))  ) = (CANIDT4>>3)+(CANIDT3<<5);
*/
		*((U8 *)(&(identifier))+3) =  CANIDT1              ;
 44a:	80 91 f3 00 	lds	r24, 0x00F3
 44e:	8c 83       	std	Y+4, r24	; 0x04
		*((U8 *)(&(identifier))+2) = (CANIDT2 & 0xF0)+((CANIDT2 & 0x08)>>3);
 450:	80 91 f2 00 	lds	r24, 0x00F2
 454:	90 91 f2 00 	lds	r25, 0x00F2
 458:	93 fb       	bst	r25, 3
 45a:	99 27       	eor	r25, r25
 45c:	90 f9       	bld	r25, 0
 45e:	80 7f       	andi	r24, 0xF0	; 240
 460:	89 0f       	add	r24, r25
 462:	8b 83       	std	Y+3, r24	; 0x03
		*((U8 *)(&(identifier))+1) = (CANIDT3>>3)+(CANIDT2<<5);
 464:	80 91 f1 00 	lds	r24, 0x00F1
 468:	90 91 f2 00 	lds	r25, 0x00F2
 46c:	86 95       	lsr	r24
 46e:	86 95       	lsr	r24
 470:	86 95       	lsr	r24
 472:	20 e2       	ldi	r18, 0x20	; 32
 474:	92 9f       	mul	r25, r18
 476:	80 0d       	add	r24, r0
 478:	11 24       	eor	r1, r1
 47a:	8a 83       	std	Y+2, r24	; 0x02
		*((U8 *)(&(identifier))  ) = (CANIDT4>>3)+(CANIDT3<<5);
 47c:	80 91 f0 00 	lds	r24, 0x00F0
 480:	90 91 f1 00 	lds	r25, 0x00F1
 484:	86 95       	lsr	r24
 486:	86 95       	lsr	r24
 488:	86 95       	lsr	r24
 48a:	20 e2       	ldi	r18, 0x20	; 32
 48c:	92 9f       	mul	r25, r18
 48e:	80 0d       	add	r24, r0
 490:	11 24       	eor	r1, r1
 492:	89 83       	std	Y+1, r24	; 0x01
				
		recMsg->id = HIGH_WORD(identifier);
 494:	89 81       	ldd	r24, Y+1	; 0x01
 496:	9a 81       	ldd	r25, Y+2	; 0x02
 498:	ab 81       	ldd	r26, Y+3	; 0x03
 49a:	bc 81       	ldd	r27, Y+4	; 0x04
 49c:	b2 83       	std	Z+2, r27	; 0x02
 49e:	a1 83       	std	Z+1, r26	; 0x01
		recMsg->ext = LOW_WORD(identifier);
 4a0:	94 83       	std	Z+4, r25	; 0x04
 4a2:	83 83       	std	Z+3, r24	; 0x03
 4a4:	14 c0       	rjmp	.+40     	; 0x4ce <__vector_18+0x12a>
	} else {
  		// get id of selected MOb
  		recMsg->id = 0;
 4a6:	12 82       	std	Z+2, r1	; 0x02
 4a8:	11 82       	std	Z+1, r1	; 0x01
  		recMsg->id |= ((uint16_t) CANIDT1<<8);
 4aa:	80 91 f3 00 	lds	r24, 0x00F3
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	98 2f       	mov	r25, r24
 4b2:	88 27       	eor	r24, r24
 4b4:	92 83       	std	Z+2, r25	; 0x02
 4b6:	81 83       	std	Z+1, r24	; 0x01
  		recMsg->id |= (CANIDT2&0xE0);
 4b8:	20 91 f2 00 	lds	r18, 0x00F2
 4bc:	20 7e       	andi	r18, 0xE0	; 224
 4be:	82 2b       	or	r24, r18
  		recMsg->id >>= 5;
 4c0:	75 e0       	ldi	r23, 0x05	; 5
 4c2:	96 95       	lsr	r25
 4c4:	87 95       	ror	r24
 4c6:	7a 95       	dec	r23
 4c8:	e1 f7       	brne	.-8      	; 0x4c2 <__vector_18+0x11e>
 4ca:	92 83       	std	Z+2, r25	; 0x02
 4cc:	81 83       	std	Z+1, r24	; 0x01
	}
	

    // get length of selected MOb
    recMsg->length = (CANCDMOB&0x0F);
 4ce:	20 91 ef 00 	lds	r18, 0x00EF
 4d2:	2f 70       	andi	r18, 0x0F	; 15
 4d4:	25 83       	std	Z+5, r18	; 0x05
 4d6:	80 e0       	ldi	r24, 0x00	; 0
 4d8:	90 e0       	ldi	r25, 0x00	; 0
 4da:	df 01       	movw	r26, r30
 4dc:	a8 0f       	add	r26, r24
 4de:	b9 1f       	adc	r27, r25

    // clear memory
	for (i=0; i<8; i++)	
	{	
	  recMsg->data[i] = 0;
 4e0:	16 96       	adiw	r26, 0x06	; 6
 4e2:	1c 92       	st	X, r1
 4e4:	01 96       	adiw	r24, 0x01	; 1

    // get length of selected MOb
    recMsg->length = (CANCDMOB&0x0F);

    // clear memory
	for (i=0; i<8; i++)	
 4e6:	88 30       	cpi	r24, 0x08	; 8
 4e8:	91 05       	cpc	r25, r1
 4ea:	b9 f7       	brne	.-18     	; 0x4da <__vector_18+0x136>
 4ec:	80 e0       	ldi	r24, 0x00	; 0
 4ee:	90 e0       	ldi	r25, 0x00	; 0
	{	
	  recMsg->data[i] = 0;
	}

    // get data of selected MOb
	for (i=0; i<recMsg->length; i++)	
 4f0:	82 17       	cp	r24, r18
 4f2:	48 f4       	brcc	.+18     	; 0x506 <__vector_18+0x162>
	{	
	  recMsg->data[i] = CANMSG;
 4f4:	30 91 fa 00 	lds	r19, 0x00FA
 4f8:	df 01       	movw	r26, r30
 4fa:	a8 0f       	add	r26, r24
 4fc:	b9 1f       	adc	r27, r25
 4fe:	16 96       	adiw	r26, 0x06	; 6
 500:	3c 93       	st	X, r19
 502:	01 96       	adiw	r24, 0x01	; 1
 504:	f5 cf       	rjmp	.-22     	; 0x4f0 <__vector_18+0x14c>
	}

    readmodwrite = CANSTMOB;
 506:	80 91 ee 00 	lds	r24, 0x00EE
    readmodwrite &= ~(1<<RXOK);  //  reset interrupt 	
 50a:	8f 7d       	andi	r24, 0xDF	; 223
    CANSTMOB = readmodwrite;
 50c:	80 93 ee 00 	sts	0x00EE, r24
	CANCDMOB = (1<<CONMOB1);  //  stay tuned!
 510:	80 e8       	ldi	r24, 0x80	; 128
 512:	80 93 ef 00 	sts	0x00EF, r24
  }

  CANPAGE = save_canpage;  //  restore CANPAGE
 516:	10 93 ed 00 	sts	0x00ED, r17
}
 51a:	0f 90       	pop	r0
 51c:	0f 90       	pop	r0
 51e:	0f 90       	pop	r0
 520:	0f 90       	pop	r0
 522:	df 91       	pop	r29
 524:	cf 91       	pop	r28
 526:	ff 91       	pop	r31
 528:	ef 91       	pop	r30
 52a:	bf 91       	pop	r27
 52c:	af 91       	pop	r26
 52e:	9f 91       	pop	r25
 530:	8f 91       	pop	r24
 532:	7f 91       	pop	r23
 534:	6f 91       	pop	r22
 536:	5f 91       	pop	r21
 538:	4f 91       	pop	r20
 53a:	3f 91       	pop	r19
 53c:	2f 91       	pop	r18
 53e:	1f 91       	pop	r17
 540:	0f 90       	pop	r0
 542:	0b be       	out	0x3b, r0	; 59
 544:	0f 90       	pop	r0
 546:	0f be       	out	0x3f, r0	; 63
 548:	0f 90       	pop	r0
 54a:	1f 90       	pop	r1
 54c:	18 95       	reti

0000054e <OW_out_low>:
char OW_get_state(){
	return (OW_IN & (1<<OW_BIT));
}

void OW_out_low(){	
	OW_DDR |= (1 << OW_BIT);
 54e:	0e 9a       	sbi	0x01, 6	; 1
	OW_OUT &= (~(1 << OW_BIT));
 550:	16 98       	cbi	0x02, 6	; 2
 552:	08 95       	ret

00000554 <OW_out_high>:
}

void OW_out_high(){
	OW_DDR |= (1 << OW_BIT);
 554:	0e 9a       	sbi	0x01, 6	; 1
	OW_DDR |= (1 << OW_BIT);
 556:	0e 9a       	sbi	0x01, 6	; 1
 558:	08 95       	ret

0000055a <OW_reset_pulse>:
	return OW_get_state();
}

unsigned char OW_reset_pulse(void){
	unsigned char status;
	OW_out_low();
 55a:	0e 94 a7 02 	call	0x54e	; 0x54e <OW_out_low>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 55e:	8f ec       	ldi	r24, 0xCF	; 207
 560:	97 e0       	ldi	r25, 0x07	; 7
 562:	01 97       	sbiw	r24, 0x01	; 1
 564:	f1 f7       	brne	.-4      	; 0x562 <OW_reset_pulse+0x8>
 566:	00 c0       	rjmp	.+0      	; 0x568 <OW_reset_pulse+0xe>
 568:	00 00       	nop
	_delay_us(500);//delay(500);
	OW_out_high();
 56a:	0e 94 aa 02 	call	0x554	; 0x554 <OW_out_high>
 56e:	90 ea       	ldi	r25, 0xA0	; 160
 570:	9a 95       	dec	r25
 572:	f1 f7       	brne	.-4      	; 0x570 <OW_reset_pulse+0x16>
#define OW_DDR	DDRA
#define OW_PIN	PINA


char OW_get_state(){
	return (OW_IN & (1<<OW_BIT));
 574:	80 b1       	in	r24, 0x00	; 0
 576:	87 e5       	ldi	r24, 0x57	; 87
 578:	97 e0       	ldi	r25, 0x07	; 7
 57a:	01 97       	sbiw	r24, 0x01	; 1
 57c:	f1 f7       	brne	.-4      	; 0x57a <OW_reset_pulse+0x20>
 57e:	00 c0       	rjmp	.+0      	; 0x580 <OW_reset_pulse+0x26>
 580:	00 00       	nop
 582:	80 b1       	in	r24, 0x00	; 0
	_delay_us(30);//delay(30);
	status = OW_get_state();
	_delay_us(470);//delay(470);
	status = OW_get_state();
	return status;
}
 584:	80 74       	andi	r24, 0x40	; 64
 586:	08 95       	ret

00000588 <led_on>:
void led_uart_toogle(void){
	led_g_toogle();
}
	
void led_on(uint8_t port, uint8_t led){
	if (port == LED_Y_PORT) {
 588:	92 b1       	in	r25, 0x02	; 2
 58a:	89 13       	cpse	r24, r25
 58c:	0a c0       	rjmp	.+20     	; 0x5a2 <led_on+0x1a>
		LED_Y_PORT |= (1<<led);
 58e:	92 b1       	in	r25, 0x02	; 2
 590:	21 e0       	ldi	r18, 0x01	; 1
 592:	30 e0       	ldi	r19, 0x00	; 0
 594:	06 2e       	mov	r0, r22
 596:	01 c0       	rjmp	.+2      	; 0x59a <led_on+0x12>
 598:	22 0f       	add	r18, r18
 59a:	0a 94       	dec	r0
 59c:	ea f7       	brpl	.-6      	; 0x598 <led_on+0x10>
 59e:	92 2b       	or	r25, r18
 5a0:	92 b9       	out	0x02, r25	; 2
	}
	if (port == LED_G_PORT){
 5a2:	94 b3       	in	r25, 0x14	; 20
 5a4:	89 13       	cpse	r24, r25
 5a6:	0a c0       	rjmp	.+20     	; 0x5bc <led_on+0x34>
		LED_G_PORT |= (1<<led);
 5a8:	24 b3       	in	r18, 0x14	; 20
 5aa:	81 e0       	ldi	r24, 0x01	; 1
 5ac:	90 e0       	ldi	r25, 0x00	; 0
 5ae:	06 2e       	mov	r0, r22
 5b0:	01 c0       	rjmp	.+2      	; 0x5b4 <led_on+0x2c>
 5b2:	88 0f       	add	r24, r24
 5b4:	0a 94       	dec	r0
 5b6:	ea f7       	brpl	.-6      	; 0x5b2 <led_on+0x2a>
 5b8:	28 2b       	or	r18, r24
 5ba:	24 bb       	out	0x14, r18	; 20
 5bc:	08 95       	ret

000005be <led_off>:
	}
}

void led_off(uint8_t port, uint8_t led){
	if (port == LED_Y_PORT){
 5be:	92 b1       	in	r25, 0x02	; 2
 5c0:	89 13       	cpse	r24, r25
 5c2:	0b c0       	rjmp	.+22     	; 0x5da <led_off+0x1c>
		LED_Y_PORT &= ~(1<<led);
 5c4:	92 b1       	in	r25, 0x02	; 2
 5c6:	21 e0       	ldi	r18, 0x01	; 1
 5c8:	30 e0       	ldi	r19, 0x00	; 0
 5ca:	06 2e       	mov	r0, r22
 5cc:	01 c0       	rjmp	.+2      	; 0x5d0 <led_off+0x12>
 5ce:	22 0f       	add	r18, r18
 5d0:	0a 94       	dec	r0
 5d2:	ea f7       	brpl	.-6      	; 0x5ce <led_off+0x10>
 5d4:	20 95       	com	r18
 5d6:	29 23       	and	r18, r25
 5d8:	22 b9       	out	0x02, r18	; 2
	}
	if (port == LED_G_PORT){
 5da:	94 b3       	in	r25, 0x14	; 20
 5dc:	89 13       	cpse	r24, r25
 5de:	0b c0       	rjmp	.+22     	; 0x5f6 <led_off+0x38>
		LED_G_PORT &= ~(1<<led);
 5e0:	24 b3       	in	r18, 0x14	; 20
 5e2:	81 e0       	ldi	r24, 0x01	; 1
 5e4:	90 e0       	ldi	r25, 0x00	; 0
 5e6:	06 2e       	mov	r0, r22
 5e8:	01 c0       	rjmp	.+2      	; 0x5ec <led_off+0x2e>
 5ea:	88 0f       	add	r24, r24
 5ec:	0a 94       	dec	r0
 5ee:	ea f7       	brpl	.-6      	; 0x5ea <led_off+0x2c>
 5f0:	80 95       	com	r24
 5f2:	82 23       	and	r24, r18
 5f4:	84 bb       	out	0x14, r24	; 20
 5f6:	08 95       	ret

000005f8 <led_y_on>:
	}
}

void led_y_on(void){
	led_on(LED_Y_PORT, LED_Y);		
 5f8:	82 b1       	in	r24, 0x02	; 2
 5fa:	67 e0       	ldi	r22, 0x07	; 7
 5fc:	0c 94 c4 02 	jmp	0x588	; 0x588 <led_on>

00000600 <led_y_off>:
}

void led_y_off(void){
	led_off(LED_Y_PORT, LED_Y);
 600:	82 b1       	in	r24, 0x02	; 2
 602:	67 e0       	ldi	r22, 0x07	; 7
 604:	0c 94 df 02 	jmp	0x5be	; 0x5be <led_off>

00000608 <led_y_toogle>:
}
void led_y_toogle(void){
	if(bit_is_set(LED_Y_PORT, LED_Y)){
 608:	17 9b       	sbis	0x02, 7	; 2
 60a:	04 c0       	rjmp	.+8      	; 0x614 <led_y_toogle+0xc>
		led_off(LED_Y_PORT, LED_Y);
 60c:	82 b1       	in	r24, 0x02	; 2
 60e:	67 e0       	ldi	r22, 0x07	; 7
 610:	0c 94 df 02 	jmp	0x5be	; 0x5be <led_off>
	}
	else{
		led_on(LED_Y_PORT, LED_Y);
 614:	82 b1       	in	r24, 0x02	; 2
 616:	67 e0       	ldi	r22, 0x07	; 7
 618:	0c 94 c4 02 	jmp	0x588	; 0x588 <led_on>

0000061c <led_g_on>:
	}
}

void led_g_on(void){
	led_on(LED_G_PORT, LED_G);
 61c:	84 b3       	in	r24, 0x14	; 20
 61e:	62 e0       	ldi	r22, 0x02	; 2
 620:	0c 94 c4 02 	jmp	0x588	; 0x588 <led_on>

00000624 <led_g_off>:
}
void led_g_off(void){
	led_off(LED_G_PORT, LED_G);
 624:	84 b3       	in	r24, 0x14	; 20
 626:	62 e0       	ldi	r22, 0x02	; 2
 628:	0c 94 df 02 	jmp	0x5be	; 0x5be <led_off>

0000062c <led_init>:
#include "led.h"

void led_init(){
	LED_Y_DDR |= (1<<LED_Y);
 62c:	0f 9a       	sbi	0x01, 7	; 1
	LED_G_DDR |= (1<<LED_G);
 62e:	9a 9a       	sbi	0x13, 2	; 19
	led_y_off();
 630:	0e 94 00 03 	call	0x600	; 0x600 <led_y_off>
	led_g_off();
 634:	0c 94 12 03 	jmp	0x624	; 0x624 <led_g_off>

00000638 <led_g_toogle>:
}
void led_g_off(void){
	led_off(LED_G_PORT, LED_G);
}
void led_g_toogle(void){
	if(bit_is_set(LED_G_PORT, LED_G)){
 638:	a2 9b       	sbis	0x14, 2	; 20
 63a:	04 c0       	rjmp	.+8      	; 0x644 <led_g_toogle+0xc>
		led_off(LED_G_PORT, LED_G);
 63c:	84 b3       	in	r24, 0x14	; 20
 63e:	62 e0       	ldi	r22, 0x02	; 2
 640:	0c 94 df 02 	jmp	0x5be	; 0x5be <led_off>
	}
	else{
		led_on(LED_G_PORT, LED_G);
 644:	84 b3       	in	r24, 0x14	; 20
 646:	62 e0       	ldi	r22, 0x02	; 2
 648:	0c 94 c4 02 	jmp	0x588	; 0x588 <led_on>

0000064c <rtc_int_init>:

void rtc_int_init(void)
{
U16 i;
    
    Disable_interrupt();
 64c:	f8 94       	cli

    Timer8_clear();                 //-- Timer 2 cleared & initialized "OFF"
 64e:	10 92 b0 00 	sts	0x00B0, r1
 652:	10 92 b2 00 	sts	0x00B2, r1
 656:	10 92 b3 00 	sts	0x00B3, r1
    for (i=0;i<0xFFFF;i++);         //-- Waiting to let the Xtal stabilize after a power-on
    Timer8_overflow_it_disable();   //-- Disable OCIE2A interrupt
 65a:	80 91 70 00 	lds	r24, 0x0070
 65e:	8e 7f       	andi	r24, 0xFE	; 254
 660:	80 93 70 00 	sts	0x0070, r24
    Timer8_compare_a_it_disable();  //-- Disable TOIE2 interrupt
 664:	80 91 70 00 	lds	r24, 0x0070
 668:	8d 7f       	andi	r24, 0xFD	; 253
 66a:	80 93 70 00 	sts	0x0070, r24
    //-- Config: - CTC mode (mode 2, top=OCR2A)
    //--         - No output
    //--        (- Timer "OFF")
    Timer8_set_mode_output_a(TIMER8_COMP_MODE_NORMAL);
 66e:	80 91 b0 00 	lds	r24, 0x00B0
 672:	8f 7c       	andi	r24, 0xCF	; 207
 674:	80 93 b0 00 	sts	0x00B0, r24
    Timer8_set_waveform_mode(TIMER8_WGM_CTC_OCR);
 678:	80 91 b0 00 	lds	r24, 0x00B0
 67c:	87 7b       	andi	r24, 0xB7	; 183
 67e:	88 60       	ori	r24, 0x08	; 8
 680:	80 93 b0 00 	sts	0x00B0, r24
        //-- Tic interval: ((1/32768)*MAGIC_NUMBER) sec = 1.00708008 msec
        Timer8_set_clock(TIMER8_CLKIO_BY_1);
      
#   elif (RTC_CLOCK == 0) //-- Suppose synchronous clock = system clock

        Timer8_2_system_clk();              //-- Init System clock as clock for Timer2
 684:	80 91 b6 00 	lds	r24, 0x00B6
 688:	87 7e       	andi	r24, 0xE7	; 231
 68a:	80 93 b6 00 	sts	0x00B6, r24

    
#       if (FOSC == 16000)
            //--- Synchronous internal clock 16000 KHZ
            Timer8_set_compare_a(125-1);    //-- MAGIC_NUMBER !
 68e:	8c e7       	ldi	r24, 0x7C	; 124
 690:	80 93 b3 00 	sts	0x00B3, r24
            //-- Prescaler=128 & timer "ON"
            //-- Tic interval: ((1/16000000)*128*MAGIC_NUMBER) sec = 1.00000000 msec
            Timer8_set_clock(TIMER8_2_CLKIO_BY_128);
 694:	80 91 b0 00 	lds	r24, 0x00B0
 698:	88 7f       	andi	r24, 0xF8	; 248
 69a:	85 60       	ori	r24, 0x05	; 5
 69c:	80 93 b0 00 	sts	0x00B0, r24
#   else
#       error This RTC_CLOCK value is not available input for "rtc_drv.c" file

#   endif // (RTC_CLOCK ...
    
    while(Timer8_2_update_busy());    //-- Wait for TCN2UB, OCR2UB and TCR2UB to be cleared
 6a0:	80 91 b6 00 	lds	r24, 0x00B6
 6a4:	87 70       	andi	r24, 0x07	; 7
 6a6:	e1 f7       	brne	.-8      	; 0x6a0 <rtc_int_init+0x54>

    Timer8_clear_compare_a_it();      //-- Clear Output_Compare Interrupt-flags
 6a8:	b9 9a       	sbi	0x17, 1	; 23
    Timer8_compare_a_it_enable();     //-- Enable Timer2 Output_Compare Interrupt
 6aa:	80 91 70 00 	lds	r24, 0x0070
 6ae:	82 60       	ori	r24, 0x02	; 2
 6b0:	80 93 70 00 	sts	0x0070, r24

    //-- Time setting
    rtc_tics         = 0;
 6b4:	10 92 7e 05 	sts	0x057E, r1
 6b8:	10 92 7f 05 	sts	0x057F, r1
 6bc:	10 92 80 05 	sts	0x0580, r1
 6c0:	10 92 81 05 	sts	0x0581, r1
    rtc_milliseconds = 0;
 6c4:	10 92 7d 05 	sts	0x057D, r1
 6c8:	10 92 7c 05 	sts	0x057C, r1
    rtc_seconds      = 0;
 6cc:	10 92 83 05 	sts	0x0583, r1
    rtc_minutes      = 0;
 6d0:	10 92 79 05 	sts	0x0579, r1
    rtc_hours        = 0;
 6d4:	10 92 82 05 	sts	0x0582, r1
    rtc_days         = 0;
 6d8:	10 92 7b 05 	sts	0x057B, r1
	flag_minute		 = 0;
 6dc:	10 92 7a 05 	sts	0x057A, r1

    rtc_running = ON;
 6e0:	81 e0       	ldi	r24, 0x01	; 1
 6e2:	80 93 99 01 	sts	0x0199, r24
    Enable_interrupt();
 6e6:	78 94       	sei
 6e8:	08 95       	ret

000006ea <__vector_9>:
//!
//------------------------------------------------------------------------------
#if (RTC_TIMER == 2)

ISR(TIMER2_COMP_vect)
{
 6ea:	1f 92       	push	r1
 6ec:	0f 92       	push	r0
 6ee:	0f b6       	in	r0, 0x3f	; 63
 6f0:	0f 92       	push	r0
 6f2:	11 24       	eor	r1, r1
 6f4:	2f 93       	push	r18
 6f6:	8f 93       	push	r24
 6f8:	9f 93       	push	r25
 6fa:	af 93       	push	r26
 6fc:	bf 93       	push	r27
    rtc_tics++;                     //-- Increments tics
 6fe:	80 91 7e 05 	lds	r24, 0x057E
 702:	90 91 7f 05 	lds	r25, 0x057F
 706:	a0 91 80 05 	lds	r26, 0x0580
 70a:	b0 91 81 05 	lds	r27, 0x0581
 70e:	01 96       	adiw	r24, 0x01	; 1
 710:	a1 1d       	adc	r26, r1
 712:	b1 1d       	adc	r27, r1
 714:	80 93 7e 05 	sts	0x057E, r24
 718:	90 93 7f 05 	sts	0x057F, r25
 71c:	a0 93 80 05 	sts	0x0580, r26
 720:	b0 93 81 05 	sts	0x0581, r27
    rtc_milliseconds++;             //-- Increments milli seconds
 724:	80 91 7c 05 	lds	r24, 0x057C
 728:	90 91 7d 05 	lds	r25, 0x057D
 72c:	01 96       	adiw	r24, 0x01	; 1
 72e:	90 93 7d 05 	sts	0x057D, r25
 732:	80 93 7c 05 	sts	0x057C, r24
    
    if (rtc_milliseconds == 1000)
 736:	80 91 7c 05 	lds	r24, 0x057C
 73a:	90 91 7d 05 	lds	r25, 0x057D
 73e:	88 3e       	cpi	r24, 0xE8	; 232
 740:	93 40       	sbci	r25, 0x03	; 3
 742:	69 f5       	brne	.+90     	; 0x79e <__vector_9+0xb4>
    {
        rtc_milliseconds = 0;
 744:	10 92 7d 05 	sts	0x057D, r1
 748:	10 92 7c 05 	sts	0x057C, r1
        rtc_seconds++;              //-- Increments seconds
 74c:	80 91 83 05 	lds	r24, 0x0583
 750:	8f 5f       	subi	r24, 0xFF	; 255
 752:	80 93 83 05 	sts	0x0583, r24
		flag_minute =1;
 756:	81 e0       	ldi	r24, 0x01	; 1
 758:	80 93 7a 05 	sts	0x057A, r24
		
        if (rtc_seconds == 60)
 75c:	80 91 83 05 	lds	r24, 0x0583
 760:	8c 33       	cpi	r24, 0x3C	; 60
 762:	e9 f4       	brne	.+58     	; 0x79e <__vector_9+0xb4>
        {
            rtc_seconds = 0;	
 764:	10 92 83 05 	sts	0x0583, r1
            rtc_minutes++;          //-- Increments minutes
 768:	80 91 79 05 	lds	r24, 0x0579
 76c:	8f 5f       	subi	r24, 0xFF	; 255
 76e:	80 93 79 05 	sts	0x0579, r24
            
            if (rtc_minutes == 60)
 772:	80 91 79 05 	lds	r24, 0x0579
 776:	8c 33       	cpi	r24, 0x3C	; 60
 778:	91 f4       	brne	.+36     	; 0x79e <__vector_9+0xb4>
            {
                rtc_minutes = 0;
 77a:	10 92 79 05 	sts	0x0579, r1
				
                rtc_hours++;        //-- Increments hours
 77e:	80 91 82 05 	lds	r24, 0x0582
 782:	8f 5f       	subi	r24, 0xFF	; 255
 784:	80 93 82 05 	sts	0x0582, r24
                        
                if (rtc_hours == 24)
 788:	80 91 82 05 	lds	r24, 0x0582
 78c:	88 31       	cpi	r24, 0x18	; 24
 78e:	39 f4       	brne	.+14     	; 0x79e <__vector_9+0xb4>
                {
                    rtc_hours = 0;
 790:	10 92 82 05 	sts	0x0582, r1
                    rtc_days++;     //-- Increments days
 794:	80 91 7b 05 	lds	r24, 0x057B
 798:	8f 5f       	subi	r24, 0xFF	; 255
 79a:	80 93 7b 05 	sts	0x057B, r24
                }
            }
        }
    }
}
 79e:	bf 91       	pop	r27
 7a0:	af 91       	pop	r26
 7a2:	9f 91       	pop	r25
 7a4:	8f 91       	pop	r24
 7a6:	2f 91       	pop	r18
 7a8:	0f 90       	pop	r0
 7aa:	0f be       	out	0x3f, r0	; 63
 7ac:	0f 90       	pop	r0
 7ae:	1f 90       	pop	r1
 7b0:	18 95       	reti

000007b2 <uart_rx_get_3_data>:
Bool uart_rx_get_3_data (void)
{
U8 u8_temp = 0;

#if ((USE_UART == UART_0) || (USE_UART == UART_1))
    u8_temp = Uart_rx_get_3_data();
 7b2:	8c b1       	in	r24, 0x0c	; 12
 7b4:	2c b1       	in	r18, 0x0c	; 12
 7b6:	9c b1       	in	r25, 0x0c	; 12
 7b8:	82 23       	and	r24, r18
 7ba:	81 70       	andi	r24, 0x01	; 1
#   else
#       error USE_UART definition is not referenced in "uart_drv.h" file
#endif

    return u8_temp;
}
 7bc:	89 23       	and	r24, r25
 7be:	08 95       	ret

000007c0 <uart_set_baudrate>:
//! @return Baudrate Status
//!         ==0: baudrate configuration failed
//!         ==1: baudrate performed
//------------------------------------------------------------------------------
U8 uart_set_baudrate (U32 baudrate)
{
 7c0:	cf 92       	push	r12
 7c2:	df 92       	push	r13
 7c4:	ef 92       	push	r14
 7c6:	ff 92       	push	r15
 7c8:	0f 93       	push	r16
 7ca:	1f 93       	push	r17
 7cc:	cf 93       	push	r28
 7ce:	df 93       	push	r29
    U16 t_meas_0, t_meas_1, t_meas_2, t_meas_3, t_meas_4;
    U16 t_min, t_max;

    if (baudrate != 0)
 7d0:	61 15       	cp	r22, r1
 7d2:	71 05       	cpc	r23, r1
 7d4:	81 05       	cpc	r24, r1
 7d6:	91 05       	cpc	r25, r1
 7d8:	c1 f0       	breq	.+48     	; 0x80a <uart_set_baudrate+0x4a>
    {
        // UBRRN Value (rounded to nearest division) with U2Xn=1
        t_meas_4 = (U16)(( (((((U32)FOSC*1000)<<1)/((U32)baudrate*8))+1)>>1)-1);
 7da:	9b 01       	movw	r18, r22
 7dc:	ac 01       	movw	r20, r24
 7de:	73 e0       	ldi	r23, 0x03	; 3
 7e0:	22 0f       	add	r18, r18
 7e2:	33 1f       	adc	r19, r19
 7e4:	44 1f       	adc	r20, r20
 7e6:	55 1f       	adc	r21, r21
 7e8:	7a 95       	dec	r23
 7ea:	d1 f7       	brne	.-12     	; 0x7e0 <uart_set_baudrate+0x20>
 7ec:	60 e0       	ldi	r22, 0x00	; 0
 7ee:	78 e4       	ldi	r23, 0x48	; 72
 7f0:	88 ee       	ldi	r24, 0xE8	; 232
 7f2:	91 e0       	ldi	r25, 0x01	; 1
 7f4:	0e 94 50 07 	call	0xea0	; 0xea0 <__udivmodsi4>
 7f8:	2f 5f       	subi	r18, 0xFF	; 255
 7fa:	3f 4f       	sbci	r19, 0xFF	; 255
 7fc:	4f 4f       	sbci	r20, 0xFF	; 255
 7fe:	5f 4f       	sbci	r21, 0xFF	; 255
 800:	56 95       	lsr	r21
 802:	47 95       	ror	r20
 804:	37 95       	ror	r19
 806:	27 95       	ror	r18
 808:	aa c0       	rjmp	.+340    	; 0x95e <uart_set_baudrate+0x19e>
    }
    else    // Wait for only one "U" ASCII Char (0x55)
            // Autobaud using "USE_TIMER16" definition
    {
        // Autobaud set-up
        Uart_rx_in_pu_on();     // RxD in input + pull up
 80a:	68 98       	cbi	0x0d, 0	; 13
 80c:	70 9a       	sbi	0x0e, 0	; 14
        Uart_tx_in_pu_on();     // TxD in input + pull up
 80e:	69 98       	cbi	0x0d, 1	; 13
 810:	71 9a       	sbi	0x0e, 1	; 14
        Timer16_clear();        // Flush, Disable and Reset TIMER16
 812:	10 92 81 00 	sts	0x0081, r1
 816:	10 92 80 00 	sts	0x0080, r1
 81a:	10 92 82 00 	sts	0x0082, r1
 81e:	10 92 85 00 	sts	0x0085, r1
 822:	10 92 84 00 	sts	0x0084, r1
 826:	10 92 89 00 	sts	0x0089, r1
 82a:	10 92 88 00 	sts	0x0088, r1
 82e:	10 92 8b 00 	sts	0x008B, r1
 832:	10 92 8a 00 	sts	0x008A, r1
 836:	10 92 8d 00 	sts	0x008D, r1
 83a:	10 92 8c 00 	sts	0x008C, r1
 83e:	10 92 87 00 	sts	0x0087, r1
 842:	10 92 86 00 	sts	0x0086, r1
// processed on all falling edges,  the start of the whole measurement will be
// done from the start of bit 1 (failling edge detection) of the 'U' character.
//
#ifndef SOF_DETECTED        
        // Wait for falling edge of SOF.
        while (uart_rx_get_3_data() == 0);  // Wait for RxD=1
 846:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <uart_rx_get_3_data>
 84a:	88 23       	and	r24, r24
 84c:	e1 f3       	breq	.-8      	; 0x846 <uart_set_baudrate+0x86>
        while (uart_rx_get_data()   != 0);  // Wait for RxD=0
 84e:	60 99       	sbic	0x0c, 0	; 12
 850:	fe cf       	rjmp	.-4      	; 0x84e <uart_set_baudrate+0x8e>

        // SOF Detected => Start Timer
        Timer16_set_clock(TIMER16_CLKIO_BY_1);     
 852:	80 91 81 00 	lds	r24, 0x0081
 856:	88 7f       	andi	r24, 0xF8	; 248
 858:	81 60       	ori	r24, 0x01	; 1
 85a:	80 93 81 00 	sts	0x0081, r24

        // SOF + bit[0] Measurement. Read 3 times to remove overshoots.
        while (uart_rx_get_3_data() == 0);  // Wait for RxD=1
 85e:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <uart_rx_get_3_data>
 862:	88 23       	and	r24, r24
 864:	e1 f3       	breq	.-8      	; 0x85e <uart_set_baudrate+0x9e>
        while (uart_rx_get_data()   != 0);  // Wait for RxD=0
 866:	60 99       	sbic	0x0c, 0	; 12
 868:	fe cf       	rjmp	.-4      	; 0x866 <uart_set_baudrate+0xa6>
        //t_meas_0 = TCNT3;
        t_meas_0  =  Timer16_get_counter_low();
 86a:	c0 91 84 00 	lds	r28, 0x0084
        t_meas_0 |= (Timer16_get_counter_high() << 8 );
 86e:	80 91 85 00 	lds	r24, 0x0085
 872:	d0 e0       	ldi	r29, 0x00	; 0
 874:	d8 2b       	or	r29, r24

        // SOF + bit[0:2] Measurement. Read 3 times to remove overshoots.
        while (uart_rx_get_3_data() == 0);  // Wait for RxD=1
 876:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <uart_rx_get_3_data>
 87a:	88 23       	and	r24, r24
 87c:	e1 f3       	breq	.-8      	; 0x876 <uart_set_baudrate+0xb6>
        while (uart_rx_get_data()   != 0);  // Wait for RxD=0
 87e:	60 99       	sbic	0x0c, 0	; 12
 880:	fe cf       	rjmp	.-4      	; 0x87e <uart_set_baudrate+0xbe>
        t_meas_1  =  Timer16_get_counter_low();
 882:	e0 90 84 00 	lds	r14, 0x0084
        t_meas_1 |= (Timer16_get_counter_high() << 8 );
 886:	f0 90 85 00 	lds	r15, 0x0085

        // SOF + bit[0:4] Measurement. Read 3 times to remove overshoots.
        while (uart_rx_get_3_data() == 0);  // Wait for RxD=1
 88a:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <uart_rx_get_3_data>
 88e:	88 23       	and	r24, r24
 890:	e1 f3       	breq	.-8      	; 0x88a <uart_set_baudrate+0xca>
        while (uart_rx_get_data()   != 0);  // Wait for RxD=0
 892:	60 99       	sbic	0x0c, 0	; 12
 894:	fe cf       	rjmp	.-4      	; 0x892 <uart_set_baudrate+0xd2>
        t_meas_2  =  Timer16_get_counter_low();
 896:	c0 90 84 00 	lds	r12, 0x0084
        t_meas_2 |= (Timer16_get_counter_high() << 8 );
 89a:	d0 90 85 00 	lds	r13, 0x0085

        // SOF + bit[0:6] Measurement. Read 3 times to remove overshoots.
        while (uart_rx_get_3_data() == 0);  // Wait for RxD=1
 89e:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <uart_rx_get_3_data>
 8a2:	88 23       	and	r24, r24
 8a4:	e1 f3       	breq	.-8      	; 0x89e <uart_set_baudrate+0xde>
        while (uart_rx_get_data()   != 0);  // Wait for RxD=0
 8a6:	60 99       	sbic	0x0c, 0	; 12
 8a8:	fe cf       	rjmp	.-4      	; 0x8a6 <uart_set_baudrate+0xe6>
        t_meas_3  =  Timer16_get_counter_low();
 8aa:	20 91 84 00 	lds	r18, 0x0084
        t_meas_3 |= (Timer16_get_counter_high() << 8 );
 8ae:	80 91 85 00 	lds	r24, 0x0085
 8b2:	30 e0       	ldi	r19, 0x00	; 0
 8b4:	38 2b       	or	r19, r24

        // SOF + bit[0:7] Measurement. Only 1 read because looking for _/ edge.
        while (uart_rx_get_data()   == 0);  // Wait for RxD=1
 8b6:	60 9b       	sbis	0x0c, 0	; 12
 8b8:	fe cf       	rjmp	.-4      	; 0x8b6 <uart_set_baudrate+0xf6>
        t_meas_4  =  Timer16_get_counter_low();
 8ba:	80 91 84 00 	lds	r24, 0x0084
        t_meas_4 |= (Timer16_get_counter_high() << 8 );
 8be:	40 91 85 00 	lds	r20, 0x0085
 8c2:	90 e0       	ldi	r25, 0x00	; 0
 8c4:	94 2b       	or	r25, r20

        // End of Frame
        Timer16_off();
 8c6:	40 91 81 00 	lds	r20, 0x0081
 8ca:	48 7f       	andi	r20, 0xF8	; 248
 8cc:	40 93 81 00 	sts	0x0081, r20
        Uart_rx_in_pu_off();     // RxD in input no pull-up
 8d0:	68 98       	cbi	0x0d, 0	; 13
 8d2:	70 98       	cbi	0x0e, 0	; 14
        Uart_tx_in_pu_off();     // TxD in input no pull-up
 8d4:	69 98       	cbi	0x0d, 1	; 13
 8d6:	71 98       	cbi	0x0e, 1	; 14

        // 1-bit (last bit) measurement
        t_meas_4 = t_meas_4 - t_meas_3;       // Bit[7]   length
 8d8:	82 1b       	sub	r24, r18
 8da:	93 0b       	sbc	r25, r19
        t_meas_1 = t_meas_1 - t_meas_0;       // Bit[1:2] length
        // t_meas_0 is already 2-bit length, SOF + bit[0] length

        // Verification if each couple of bits has an length error
        // less than 1/4 (2*1/8) of Bit[7] length
        t_min =  (2* t_meas_4) - (t_meas_4 >> 2);
 8dc:	8c 01       	movw	r16, r24
 8de:	00 0f       	add	r16, r16
 8e0:	11 1f       	adc	r17, r17
 8e2:	dc 01       	movw	r26, r24
 8e4:	b6 95       	lsr	r27
 8e6:	a7 95       	ror	r26
 8e8:	b6 95       	lsr	r27
 8ea:	a7 95       	ror	r26
        t_max =  (2* t_meas_4) + (t_meas_4 >> 2);
 8ec:	ad 01       	movw	r20, r26
 8ee:	40 0f       	add	r20, r16
 8f0:	51 1f       	adc	r21, r17
        if ((t_meas_0 > t_max) || (t_meas_0 < t_min)) return 0;
 8f2:	4c 17       	cp	r20, r28
 8f4:	5d 07       	cpc	r21, r29
 8f6:	08 f4       	brcc	.+2      	; 0x8fa <uart_set_baudrate+0x13a>
 8f8:	3f c0       	rjmp	.+126    	; 0x978 <uart_set_baudrate+0x1b8>
        t_meas_1 = t_meas_1 - t_meas_0;       // Bit[1:2] length
        // t_meas_0 is already 2-bit length, SOF + bit[0] length

        // Verification if each couple of bits has an length error
        // less than 1/4 (2*1/8) of Bit[7] length
        t_min =  (2* t_meas_4) - (t_meas_4 >> 2);
 8fa:	c8 01       	movw	r24, r16
 8fc:	8a 1b       	sub	r24, r26
 8fe:	9b 0b       	sbc	r25, r27
        t_max =  (2* t_meas_4) + (t_meas_4 >> 2);
        if ((t_meas_0 > t_max) || (t_meas_0 < t_min)) return 0;
 900:	c8 17       	cp	r28, r24
 902:	d9 07       	cpc	r29, r25
 904:	c8 f1       	brcs	.+114    	; 0x978 <uart_set_baudrate+0x1b8>

        // SOF + bit[0:2] Measurement. Read 3 times to remove overshoots.
        while (uart_rx_get_3_data() == 0);  // Wait for RxD=1
        while (uart_rx_get_data()   != 0);  // Wait for RxD=0
        t_meas_1  =  Timer16_get_counter_low();
        t_meas_1 |= (Timer16_get_counter_high() << 8 );
 906:	ee 2d       	mov	r30, r14
 908:	f0 e0       	ldi	r31, 0x00	; 0
 90a:	ff 29       	or	r31, r15
        // 1-bit (last bit) measurement
        t_meas_4 = t_meas_4 - t_meas_3;       // Bit[7]   length
        // 2-bit measurements
        t_meas_3 = t_meas_3 - t_meas_2;       // Bit[5:6] length
        t_meas_2 = t_meas_2 - t_meas_1;       // Bit[3:4] length
        t_meas_1 = t_meas_1 - t_meas_0;       // Bit[1:2] length
 90c:	df 01       	movw	r26, r30
 90e:	ac 1b       	sub	r26, r28
 910:	bd 0b       	sbc	r27, r29
        // Verification if each couple of bits has an length error
        // less than 1/4 (2*1/8) of Bit[7] length
        t_min =  (2* t_meas_4) - (t_meas_4 >> 2);
        t_max =  (2* t_meas_4) + (t_meas_4 >> 2);
        if ((t_meas_0 > t_max) || (t_meas_0 < t_min)) return 0;
        if ((t_meas_1 > t_max) || (t_meas_1 < t_min)) return 0;
 912:	4a 17       	cp	r20, r26
 914:	5b 07       	cpc	r21, r27
 916:	80 f1       	brcs	.+96     	; 0x978 <uart_set_baudrate+0x1b8>
 918:	a8 17       	cp	r26, r24
 91a:	b9 07       	cpc	r27, r25
 91c:	68 f1       	brcs	.+90     	; 0x978 <uart_set_baudrate+0x1b8>

        // SOF + bit[0:4] Measurement. Read 3 times to remove overshoots.
        while (uart_rx_get_3_data() == 0);  // Wait for RxD=1
        while (uart_rx_get_data()   != 0);  // Wait for RxD=0
        t_meas_2  =  Timer16_get_counter_low();
        t_meas_2 |= (Timer16_get_counter_high() << 8 );
 91e:	6c 2d       	mov	r22, r12
 920:	70 e0       	ldi	r23, 0x00	; 0
 922:	7d 29       	or	r23, r13

        // 1-bit (last bit) measurement
        t_meas_4 = t_meas_4 - t_meas_3;       // Bit[7]   length
        // 2-bit measurements
        t_meas_3 = t_meas_3 - t_meas_2;       // Bit[5:6] length
        t_meas_2 = t_meas_2 - t_meas_1;       // Bit[3:4] length
 924:	db 01       	movw	r26, r22
 926:	ae 1b       	sub	r26, r30
 928:	bf 0b       	sbc	r27, r31
        // less than 1/4 (2*1/8) of Bit[7] length
        t_min =  (2* t_meas_4) - (t_meas_4 >> 2);
        t_max =  (2* t_meas_4) + (t_meas_4 >> 2);
        if ((t_meas_0 > t_max) || (t_meas_0 < t_min)) return 0;
        if ((t_meas_1 > t_max) || (t_meas_1 < t_min)) return 0;
        if ((t_meas_2 > t_max) || (t_meas_2 < t_min)) return 0;
 92a:	4a 17       	cp	r20, r26
 92c:	5b 07       	cpc	r21, r27
 92e:	20 f1       	brcs	.+72     	; 0x978 <uart_set_baudrate+0x1b8>
 930:	a8 17       	cp	r26, r24
 932:	b9 07       	cpc	r27, r25
 934:	08 f1       	brcs	.+66     	; 0x978 <uart_set_baudrate+0x1b8>
        Uart_tx_in_pu_off();     // TxD in input no pull-up

        // 1-bit (last bit) measurement
        t_meas_4 = t_meas_4 - t_meas_3;       // Bit[7]   length
        // 2-bit measurements
        t_meas_3 = t_meas_3 - t_meas_2;       // Bit[5:6] length
 936:	f9 01       	movw	r30, r18
 938:	e6 1b       	sub	r30, r22
 93a:	f7 0b       	sbc	r31, r23
        t_min =  (2* t_meas_4) - (t_meas_4 >> 2);
        t_max =  (2* t_meas_4) + (t_meas_4 >> 2);
        if ((t_meas_0 > t_max) || (t_meas_0 < t_min)) return 0;
        if ((t_meas_1 > t_max) || (t_meas_1 < t_min)) return 0;
        if ((t_meas_2 > t_max) || (t_meas_2 < t_min)) return 0;
        if ((t_meas_3 > t_max) || (t_meas_3 < t_min)) return 0;
 93c:	4e 17       	cp	r20, r30
 93e:	5f 07       	cpc	r21, r31
 940:	d8 f0       	brcs	.+54     	; 0x978 <uart_set_baudrate+0x1b8>
 942:	e8 17       	cp	r30, r24
 944:	f9 07       	cpc	r31, r25
 946:	c0 f0       	brcs	.+48     	; 0x978 <uart_set_baudrate+0x1b8>

        // UBRRN Value (rounded to nearest division) with U2Xn=1
        t_meas_4  = (((((t_meas_0 + t_meas_1 + t_meas_2 + t_meas_3 ) << 1) >> 6) + 1) >> 1) - 1;
 948:	22 0f       	add	r18, r18
 94a:	33 1f       	adc	r19, r19
 94c:	96 e0       	ldi	r25, 0x06	; 6
 94e:	36 95       	lsr	r19
 950:	27 95       	ror	r18
 952:	9a 95       	dec	r25
 954:	e1 f7       	brne	.-8      	; 0x94e <uart_set_baudrate+0x18e>
 956:	2f 5f       	subi	r18, 0xFF	; 255
 958:	3f 4f       	sbci	r19, 0xFF	; 255
 95a:	36 95       	lsr	r19
 95c:	27 95       	ror	r18
 95e:	21 50       	subi	r18, 0x01	; 1
 960:	31 09       	sbc	r19, r1

#endif  // #endif of "SOF_DETECTED"

    }
    #if (USE_UART ==  UART_0)
        UBRR0H  = (U8)((t_meas_4)>>8);
 962:	30 93 c5 00 	sts	0x00C5, r19
        UBRR0L  = (U8) (t_meas_4)    ;
 966:	20 93 c4 00 	sts	0x00C4, r18
        UCSR0A |=  (1<<U2X0);
 96a:	80 91 c0 00 	lds	r24, 0x00C0
 96e:	82 60       	ori	r24, 0x02	; 2
 970:	80 93 c0 00 	sts	0x00C0, r24
        }
    #   else
    #       error USE_UART definition is not referenced in "uart_drv.h" file
    #endif
    
    return 1;
 974:	81 e0       	ldi	r24, 0x01	; 1
 976:	01 c0       	rjmp	.+2      	; 0x97a <uart_set_baudrate+0x1ba>

        // Verification if each couple of bits has an length error
        // less than 1/4 (2*1/8) of Bit[7] length
        t_min =  (2* t_meas_4) - (t_meas_4 >> 2);
        t_max =  (2* t_meas_4) + (t_meas_4 >> 2);
        if ((t_meas_0 > t_max) || (t_meas_0 < t_min)) return 0;
 978:	80 e0       	ldi	r24, 0x00	; 0
    #   else
    #       error USE_UART definition is not referenced in "uart_drv.h" file
    #endif
    
    return 1;
}
 97a:	df 91       	pop	r29
 97c:	cf 91       	pop	r28
 97e:	1f 91       	pop	r17
 980:	0f 91       	pop	r16
 982:	ff 90       	pop	r15
 984:	ef 90       	pop	r14
 986:	df 90       	pop	r13
 988:	cf 90       	pop	r12
 98a:	08 95       	ret

0000098c <uart_init>:
//!         ==0: research of timing failed
//!         ==1: baudrate performed
//!
//------------------------------------------------------------------------------
U8 uart_init (U8 mode, U32 baudrate)
{
 98c:	cf 93       	push	r28
 98e:	c8 2f       	mov	r28, r24
    Uart_clear();       // Flush, Disable and Reset UART
 990:	10 92 c1 00 	sts	0x00C1, r1
 994:	80 91 c6 00 	lds	r24, 0x00C6
 998:	80 93 c2 00 	sts	0x00C2, r24
 99c:	80 e4       	ldi	r24, 0x40	; 64
 99e:	80 93 c0 00 	sts	0x00C0, r24
 9a2:	86 e0       	ldi	r24, 0x06	; 6
 9a4:	80 93 c2 00 	sts	0x00C2, r24
 9a8:	10 92 c5 00 	sts	0x00C5, r1
 9ac:	10 92 c4 00 	sts	0x00C4, r1
    if (Uart_set_baudrate(baudrate) == 0) return 0;  //!<  c.f. macro in "uart_drv.h"
 9b0:	60 e0       	ldi	r22, 0x00	; 0
 9b2:	70 e0       	ldi	r23, 0x00	; 0
 9b4:	cb 01       	movw	r24, r22
 9b6:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <uart_set_baudrate>
 9ba:	88 23       	and	r24, r24
 9bc:	21 f1       	breq	.+72     	; 0xa06 <uart_init+0x7a>
    Uart_hw_init(mode);     //!<  c.f. macro in "uart_drv.h"
 9be:	80 91 c0 00 	lds	r24, 0x00C0
 9c2:	80 62       	ori	r24, 0x20	; 32
 9c4:	80 93 c0 00 	sts	0x00C0, r24
 9c8:	80 91 c1 00 	lds	r24, 0x00C1
 9cc:	8b 7f       	andi	r24, 0xFB	; 251
 9ce:	80 93 c1 00 	sts	0x00C1, r24
 9d2:	90 91 c1 00 	lds	r25, 0x00C1
 9d6:	8c 2f       	mov	r24, r28
 9d8:	84 70       	andi	r24, 0x04	; 4
 9da:	89 2b       	or	r24, r25
 9dc:	80 93 c1 00 	sts	0x00C1, r24
 9e0:	8c 2f       	mov	r24, r28
 9e2:	88 73       	andi	r24, 0x38	; 56
 9e4:	80 93 c2 00 	sts	0x00C2, r24
 9e8:	90 91 c2 00 	lds	r25, 0x00C2
 9ec:	8c 2f       	mov	r24, r28
 9ee:	83 70       	andi	r24, 0x03	; 3
 9f0:	88 0f       	add	r24, r24
 9f2:	89 2b       	or	r24, r25
 9f4:	80 93 c2 00 	sts	0x00C2, r24
    Uart_enable();          //!<  c.f. macro in "uart_drv.h"
 9f8:	80 91 c1 00 	lds	r24, 0x00C1
 9fc:	88 61       	ori	r24, 0x18	; 24
 9fe:	80 93 c1 00 	sts	0x00C1, r24
    return (1);
 a02:	81 e0       	ldi	r24, 0x01	; 1
 a04:	01 c0       	rjmp	.+2      	; 0xa08 <uart_init+0x7c>
//!
//------------------------------------------------------------------------------
U8 uart_init (U8 mode, U32 baudrate)
{
    Uart_clear();       // Flush, Disable and Reset UART
    if (Uart_set_baudrate(baudrate) == 0) return 0;  //!<  c.f. macro in "uart_drv.h"
 a06:	80 e0       	ldi	r24, 0x00	; 0
    Uart_hw_init(mode);     //!<  c.f. macro in "uart_drv.h"
    Uart_enable();          //!<  c.f. macro in "uart_drv.h"
    return (1);
}
 a08:	cf 91       	pop	r28
 a0a:	08 95       	ret

00000a0c <uart_putchar>:
//! @return character sent
//!
//------------------------------------------------------------------------------
U8 uart_putchar (U8 ch)
{
    while(!Uart_tx_ready());
 a0c:	90 91 c0 00 	lds	r25, 0x00C0
 a10:	95 ff       	sbrs	r25, 5
 a12:	fc cf       	rjmp	.-8      	; 0xa0c <uart_putchar>
    Uart_set_tx_busy();     // Set Busy flag before sending (always)
    Uart_send_byte(ch);
 a14:	80 93 c6 00 	sts	0x00C6, r24
    return (ch);
}
 a18:	08 95       	ret

00000a1a <uart_put_string>:
//! @return (none)
//!
//------------------------------------------------------------------------------
#ifndef REDUCED_UART_LIB
void uart_put_string (U8 *data_string)
    {
 a1a:	cf 93       	push	r28
 a1c:	df 93       	push	r29
 a1e:	ec 01       	movw	r28, r24
    while(*data_string) uart_putchar (*data_string++);
 a20:	89 91       	ld	r24, Y+
 a22:	88 23       	and	r24, r24
 a24:	19 f0       	breq	.+6      	; 0xa2c <uart_put_string+0x12>
 a26:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
 a2a:	fa cf       	rjmp	.-12     	; 0xa20 <uart_put_string+0x6>
    }
 a2c:	df 91       	pop	r29
 a2e:	cf 91       	pop	r28
 a30:	08 95       	ret

00000a32 <uart_mini_printf>:
//! Return: 0 = O.K.
//!
//------------------------------------------------------------------------------
#ifndef REDUCED_UART_LIB
U8 uart_mini_printf(char *format, ...)
{
 a32:	2f 92       	push	r2
 a34:	3f 92       	push	r3
 a36:	4f 92       	push	r4
 a38:	5f 92       	push	r5
 a3a:	6f 92       	push	r6
 a3c:	7f 92       	push	r7
 a3e:	8f 92       	push	r8
 a40:	9f 92       	push	r9
 a42:	af 92       	push	r10
 a44:	bf 92       	push	r11
 a46:	cf 92       	push	r12
 a48:	df 92       	push	r13
 a4a:	ef 92       	push	r14
 a4c:	ff 92       	push	r15
 a4e:	0f 93       	push	r16
 a50:	1f 93       	push	r17
 a52:	cf 93       	push	r28
 a54:	df 93       	push	r29
 a56:	cd b7       	in	r28, 0x3d	; 61
 a58:	de b7       	in	r29, 0x3e	; 62
 a5a:	2c 97       	sbiw	r28, 0x0c	; 12
 a5c:	0f b6       	in	r0, 0x3f	; 63
 a5e:	f8 94       	cli
 a60:	de bf       	out	0x3e, r29	; 62
 a62:	0f be       	out	0x3f, r0	; 63
 a64:	cd bf       	out	0x3d, r28	; 61
 a66:	fe 01       	movw	r30, r28
 a68:	b1 96       	adiw	r30, 0x21	; 33
 a6a:	a1 90       	ld	r10, Z+
 a6c:	b1 90       	ld	r11, Z+

    long_flag = FALSE;
    alt_p_c = FALSE;
    min_size = DATA_BUF_LEN-1;

    va_start(arg_ptr, format);   // make arg_ptr point to the first unnamed arg
 a6e:	8f 01       	movw	r16, r30
    S32     s32_val;
    U16     u16_val;
    U32     u32_val;

    long_flag = FALSE;
    alt_p_c = FALSE;
 a70:	20 e0       	ldi	r18, 0x00	; 0
    S16     s16_val;
    S32     s32_val;
    U16     u16_val;
    U32     u32_val;

    long_flag = FALSE;
 a72:	90 e0       	ldi	r25, 0x00	; 0
    alt_p_c = FALSE;
    min_size = DATA_BUF_LEN-1;
 a74:	ab e0       	ldi	r26, 0x0B	; 11
 a76:	6a 2e       	mov	r6, r26
 a78:	2e 01       	movw	r4, r28
 a7a:	6c e0       	ldi	r22, 0x0C	; 12
 a7c:	46 0e       	add	r4, r22
 a7e:	51 1c       	adc	r5, r1
                
            case 'd':
                n_sign  = FALSE;               
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
 a80:	b0 e3       	ldi	r27, 0x30	; 48
 a82:	7b 2e       	mov	r7, r27
                        n_sign = TRUE;
                        s32_val  = -s32_val;
                    }
                    while (1)
                    {
                        data_buf[data_idx] = s32_val % 10 + '0';
 a84:	8a e0       	ldi	r24, 0x0A	; 10
 a86:	c8 2e       	mov	r12, r24
 a88:	d1 2c       	mov	r13, r1
 a8a:	e1 2c       	mov	r14, r1
 a8c:	f1 2c       	mov	r15, r1
    long_flag = FALSE;
    alt_p_c = FALSE;
    min_size = DATA_BUF_LEN-1;

    va_start(arg_ptr, format);   // make arg_ptr point to the first unnamed arg
    for (p = (U8 *) format; *p; p++)
 a8e:	f5 01       	movw	r30, r10
 a90:	80 81       	ld	r24, Z
 a92:	88 23       	and	r24, r24
 a94:	09 f4       	brne	.+2      	; 0xa98 <uart_mini_printf+0x66>
 a96:	c3 c1       	rjmp	.+902    	; 0xe1e <uart_mini_printf+0x3ec>
    {
        if ((*p == '%') || (alt_p_c == TRUE))
 a98:	85 32       	cpi	r24, 0x25	; 37
 a9a:	19 f0       	breq	.+6      	; 0xaa2 <uart_mini_printf+0x70>
 a9c:	21 30       	cpi	r18, 0x01	; 1
 a9e:	09 f0       	breq	.+2      	; 0xaa2 <uart_mini_printf+0x70>
 aa0:	49 c0       	rjmp	.+146    	; 0xb34 <uart_mini_printf+0x102>
        {
            p++;
 aa2:	45 01       	movw	r8, r10
 aa4:	7f ef       	ldi	r23, 0xFF	; 255
 aa6:	87 1a       	sub	r8, r23
 aa8:	97 0a       	sbc	r9, r23
            uart_putchar(*p);
            alt_p_c = FALSE;
            long_flag = FALSE;
            continue;   // "switch (*p)" section skipped
        }
        switch (*p)
 aaa:	f5 01       	movw	r30, r10
 aac:	21 81       	ldd	r18, Z+1	; 0x01
 aae:	24 36       	cpi	r18, 0x64	; 100
 ab0:	09 f4       	brne	.+2      	; 0xab4 <uart_mini_printf+0x82>
 ab2:	46 c0       	rjmp	.+140    	; 0xb40 <uart_mini_printf+0x10e>
 ab4:	48 f4       	brcc	.+18     	; 0xac8 <uart_mini_printf+0x96>
 ab6:	28 35       	cpi	r18, 0x58	; 88
 ab8:	09 f4       	brne	.+2      	; 0xabc <uart_mini_printf+0x8a>
 aba:	f4 c0       	rjmp	.+488    	; 0xca4 <uart_mini_printf+0x272>
 abc:	23 36       	cpi	r18, 0x63	; 99
 abe:	89 f0       	breq	.+34     	; 0xae2 <uart_mini_printf+0xb0>
 ac0:	20 33       	cpi	r18, 0x30	; 48
 ac2:	09 f0       	breq	.+2      	; 0xac6 <uart_mini_printf+0x94>
 ac4:	96 c1       	rjmp	.+812    	; 0xdf2 <uart_mini_printf+0x3c0>
 ac6:	59 c1       	rjmp	.+690    	; 0xd7a <uart_mini_printf+0x348>
 ac8:	23 37       	cpi	r18, 0x73	; 115
 aca:	d9 f0       	breq	.+54     	; 0xb02 <uart_mini_printf+0xd0>
 acc:	18 f4       	brcc	.+6      	; 0xad4 <uart_mini_printf+0xa2>
 ace:	2c 36       	cpi	r18, 0x6C	; 108
 ad0:	69 f1       	breq	.+90     	; 0xb2c <uart_mini_printf+0xfa>
 ad2:	8f c1       	rjmp	.+798    	; 0xdf2 <uart_mini_printf+0x3c0>
 ad4:	25 37       	cpi	r18, 0x75	; 117
 ad6:	09 f4       	brne	.+2      	; 0xada <uart_mini_printf+0xa8>
 ad8:	98 c0       	rjmp	.+304    	; 0xc0a <uart_mini_printf+0x1d8>
 ada:	28 37       	cpi	r18, 0x78	; 120
 adc:	09 f4       	brne	.+2      	; 0xae0 <uart_mini_printf+0xae>
 ade:	e2 c0       	rjmp	.+452    	; 0xca4 <uart_mini_printf+0x272>
 ae0:	88 c1       	rjmp	.+784    	; 0xdf2 <uart_mini_printf+0x3c0>
        {
            case 'c':
                if (long_flag == TRUE)      // ERROR: 'l' before any 'c'
 ae2:	91 30       	cpi	r25, 0x01	; 1
 ae4:	29 f4       	brne	.+10     	; 0xaf0 <uart_mini_printf+0xbe>
                {
                    uart_putchar('l');
 ae6:	8c e6       	ldi	r24, 0x6C	; 108
 ae8:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                    uart_putchar('c');
 aec:	83 e6       	ldi	r24, 0x63	; 99
 aee:	88 c1       	rjmp	.+784    	; 0xe00 <uart_mini_printf+0x3ce>
                }
                else
                {
                    s8_val = (S8)(va_arg(arg_ptr, int));    // s8_val = (S8)(va_arg(arg_ptr, S16));
 af0:	58 01       	movw	r10, r16
 af2:	f2 e0       	ldi	r31, 0x02	; 2
 af4:	af 0e       	add	r10, r31
 af6:	b1 1c       	adc	r11, r1
                    uart_putchar((U8)(s8_val));
 af8:	f8 01       	movw	r30, r16
 afa:	80 81       	ld	r24, Z
 afc:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
 b00:	3a c1       	rjmp	.+628    	; 0xd76 <uart_mini_printf+0x344>
                alt_p_c = FALSE;
                long_flag = FALSE;
                break; // case 'c'
                
            case 's':
                if (long_flag == TRUE)      // ERROR: 'l' before any 's'
 b02:	91 30       	cpi	r25, 0x01	; 1
 b04:	29 f4       	brne	.+10     	; 0xb10 <uart_mini_printf+0xde>
                {
                    uart_putchar('l');
 b06:	8c e6       	ldi	r24, 0x6C	; 108
 b08:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                    uart_putchar('s');
 b0c:	83 e7       	ldi	r24, 0x73	; 115
 b0e:	78 c1       	rjmp	.+752    	; 0xe00 <uart_mini_printf+0x3ce>
                }
                else
                {
                    for (sval = va_arg(arg_ptr, U8 *); *sval; sval++)
 b10:	f8 01       	movw	r30, r16
 b12:	a0 80       	ld	r10, Z
 b14:	b1 80       	ldd	r11, Z+1	; 0x01
 b16:	0e 5f       	subi	r16, 0xFE	; 254
 b18:	1f 4f       	sbci	r17, 0xFF	; 255
 b1a:	f5 01       	movw	r30, r10
 b1c:	81 91       	ld	r24, Z+
 b1e:	5f 01       	movw	r10, r30
 b20:	88 23       	and	r24, r24
 b22:	09 f4       	brne	.+2      	; 0xb26 <uart_mini_printf+0xf4>
 b24:	6f c1       	rjmp	.+734    	; 0xe04 <uart_mini_printf+0x3d2>
                    {
                        uart_putchar(*sval);
 b26:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
 b2a:	f7 cf       	rjmp	.-18     	; 0xb1a <uart_mini_printf+0xe8>
                alt_p_c = FALSE;
                long_flag = FALSE;
                break;  // case 's'
                
            case 'l':  // It is not the number "ONE" but the lower case of "L" character
                if (long_flag == TRUE)      // ERROR: two consecutive 'l'
 b2c:	91 30       	cpi	r25, 0x01	; 1
 b2e:	09 f0       	breq	.+2      	; 0xb32 <uart_mini_printf+0x100>
 b30:	6e c1       	rjmp	.+732    	; 0xe0e <uart_mini_printf+0x3dc>
                {
                    uart_putchar('l');
 b32:	8c e6       	ldi	r24, 0x6C	; 108
 b34:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                else
                {
                    alt_p_c = TRUE;
                    long_flag = TRUE;
                }
                p--;
 b38:	45 01       	movw	r8, r10
            case 'l':  // It is not the number "ONE" but the lower case of "L" character
                if (long_flag == TRUE)      // ERROR: two consecutive 'l'
                {
                    uart_putchar('l');
                    alt_p_c = FALSE;
                    long_flag = FALSE;
 b3a:	20 e0       	ldi	r18, 0x00	; 0
 b3c:	90 e0       	ldi	r25, 0x00	; 0
 b3e:	6a c1       	rjmp	.+724    	; 0xe14 <uart_mini_printf+0x3e2>
 b40:	fe 01       	movw	r30, r28
 b42:	31 96       	adiw	r30, 0x01	; 1
                
            case 'd':
                n_sign  = FALSE;               
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
 b44:	71 92       	st	Z+, r7
                p--;
                break;  // case 'l'
                
            case 'd':
                n_sign  = FALSE;               
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
 b46:	e4 15       	cp	r30, r4
 b48:	f5 05       	cpc	r31, r5
 b4a:	e1 f7       	brne	.-8      	; 0xb44 <uart_mini_printf+0x112>
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
 b4c:	1c 86       	std	Y+12, r1	; 0x0c
                data_idx = DATA_BUF_LEN - 2;
                if (long_flag)  // 32-bit
                {
                    s32_val = va_arg(arg_ptr, S32);
 b4e:	58 01       	movw	r10, r16
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
                data_idx = DATA_BUF_LEN - 2;
                if (long_flag)  // 32-bit
 b50:	99 23       	and	r25, r25
 b52:	61 f1       	breq	.+88     	; 0xbac <uart_mini_printf+0x17a>
                {
                    s32_val = va_arg(arg_ptr, S32);
 b54:	f4 e0       	ldi	r31, 0x04	; 4
 b56:	af 0e       	add	r10, r31
 b58:	b1 1c       	adc	r11, r1
 b5a:	f8 01       	movw	r30, r16
 b5c:	60 81       	ld	r22, Z
 b5e:	71 81       	ldd	r23, Z+1	; 0x01
 b60:	82 81       	ldd	r24, Z+2	; 0x02
 b62:	93 81       	ldd	r25, Z+3	; 0x03
                    if (s32_val < 0)
 b64:	97 ff       	sbrs	r25, 7
 b66:	09 c0       	rjmp	.+18     	; 0xb7a <uart_mini_printf+0x148>
                    {
                        n_sign = TRUE;
                        s32_val  = -s32_val;
 b68:	90 95       	com	r25
 b6a:	80 95       	com	r24
 b6c:	70 95       	com	r23
 b6e:	61 95       	neg	r22
 b70:	7f 4f       	sbci	r23, 0xFF	; 255
 b72:	8f 4f       	sbci	r24, 0xFF	; 255
 b74:	9f 4f       	sbci	r25, 0xFF	; 255
                if (long_flag)  // 32-bit
                {
                    s32_val = va_arg(arg_ptr, S32);
                    if (s32_val < 0)
                    {
                        n_sign = TRUE;
 b76:	01 e0       	ldi	r16, 0x01	; 1
 b78:	01 c0       	rjmp	.+2      	; 0xb7c <uart_mini_printf+0x14a>
                }
                p--;
                break;  // case 'l'
                
            case 'd':
                n_sign  = FALSE;               
 b7a:	00 e0       	ldi	r16, 0x00	; 0
                if (long_flag)  // 32-bit
                {
                    s32_val = va_arg(arg_ptr, S32);
                    if (s32_val < 0)
                    {
                        n_sign = TRUE;
 b7c:	1a e0       	ldi	r17, 0x0A	; 10
                        s32_val  = -s32_val;
                    }
                    while (1)
                    {
                        data_buf[data_idx] = s32_val % 10 + '0';
 b7e:	22 24       	eor	r2, r2
 b80:	23 94       	inc	r2
 b82:	31 2c       	mov	r3, r1
 b84:	2c 0e       	add	r2, r28
 b86:	3d 1e       	adc	r3, r29
 b88:	21 0e       	add	r2, r17
 b8a:	31 1c       	adc	r3, r1
 b8c:	a7 01       	movw	r20, r14
 b8e:	96 01       	movw	r18, r12
 b90:	0e 94 72 07 	call	0xee4	; 0xee4 <__divmodsi4>
 b94:	60 5d       	subi	r22, 0xD0	; 208
 b96:	f1 01       	movw	r30, r2
 b98:	60 83       	st	Z, r22
                        s32_val /= 10;
 b9a:	b9 01       	movw	r22, r18
 b9c:	ca 01       	movw	r24, r20
                        data_idx--;
 b9e:	11 50       	subi	r17, 0x01	; 1
						if (s32_val==0) break;
 ba0:	61 15       	cp	r22, r1
 ba2:	71 05       	cpc	r23, r1
 ba4:	81 05       	cpc	r24, r1
 ba6:	91 05       	cpc	r25, r1
 ba8:	51 f7       	brne	.-44     	; 0xb7e <uart_mini_printf+0x14c>
 baa:	1f c0       	rjmp	.+62     	; 0xbea <uart_mini_printf+0x1b8>
                   }
                }
                else  // 16-bit
                {
                    s16_val = (S16)(va_arg(arg_ptr, int)); // s16_val = va_arg(arg_ptr, S16);
 bac:	f2 e0       	ldi	r31, 0x02	; 2
 bae:	af 0e       	add	r10, r31
 bb0:	b1 1c       	adc	r11, r1
 bb2:	f8 01       	movw	r30, r16
 bb4:	80 81       	ld	r24, Z
 bb6:	91 81       	ldd	r25, Z+1	; 0x01
                    if (s16_val < 0)
 bb8:	97 ff       	sbrs	r25, 7
 bba:	05 c0       	rjmp	.+10     	; 0xbc6 <uart_mini_printf+0x194>
                    {
                        n_sign = TRUE;
                        s16_val  = -s16_val;
 bbc:	91 95       	neg	r25
 bbe:	81 95       	neg	r24
 bc0:	91 09       	sbc	r25, r1
                else  // 16-bit
                {
                    s16_val = (S16)(va_arg(arg_ptr, int)); // s16_val = va_arg(arg_ptr, S16);
                    if (s16_val < 0)
                    {
                        n_sign = TRUE;
 bc2:	01 e0       	ldi	r16, 0x01	; 1
 bc4:	01 c0       	rjmp	.+2      	; 0xbc8 <uart_mini_printf+0x196>
                }
                p--;
                break;  // case 'l'
                
            case 'd':
                n_sign  = FALSE;               
 bc6:	00 e0       	ldi	r16, 0x00	; 0
                else  // 16-bit
                {
                    s16_val = (S16)(va_arg(arg_ptr, int)); // s16_val = va_arg(arg_ptr, S16);
                    if (s16_val < 0)
                    {
                        n_sign = TRUE;
 bc8:	1a e0       	ldi	r17, 0x0A	; 10
                        s16_val  = -s16_val;
                    }
                    while (1)
                    {
                        data_buf[data_idx] = s16_val % 10 + '0';
 bca:	e1 e0       	ldi	r30, 0x01	; 1
 bcc:	f0 e0       	ldi	r31, 0x00	; 0
 bce:	ec 0f       	add	r30, r28
 bd0:	fd 1f       	adc	r31, r29
 bd2:	e1 0f       	add	r30, r17
 bd4:	f1 1d       	adc	r31, r1
 bd6:	6a e0       	ldi	r22, 0x0A	; 10
 bd8:	70 e0       	ldi	r23, 0x00	; 0
 bda:	0e 94 3c 07 	call	0xe78	; 0xe78 <__divmodhi4>
 bde:	80 5d       	subi	r24, 0xD0	; 208
 be0:	80 83       	st	Z, r24
                        s16_val /= 10;
 be2:	cb 01       	movw	r24, r22
                        data_idx--;
 be4:	11 50       	subi	r17, 0x01	; 1
						if (s16_val==0) break;
 be6:	00 97       	sbiw	r24, 0x00	; 0
 be8:	81 f7       	brne	.-32     	; 0xbca <uart_mini_printf+0x198>
                    }
                }
                if (n_sign) { uart_putchar('-'); }
 bea:	00 23       	and	r16, r16
 bec:	19 f0       	breq	.+6      	; 0xbf4 <uart_mini_printf+0x1c2>
 bee:	8d e2       	ldi	r24, 0x2D	; 45
 bf0:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                data_idx++;
 bf4:	1f 5f       	subi	r17, 0xFF	; 255
 bf6:	61 16       	cp	r6, r17
 bf8:	08 f4       	brcc	.+2      	; 0xbfc <uart_mini_printf+0x1ca>
 bfa:	16 2d       	mov	r17, r6
                if (min_size < data_idx)
                {
                    data_idx = min_size;
                }
                uart_put_string (data_buf + data_idx);
 bfc:	81 e0       	ldi	r24, 0x01	; 1
 bfe:	90 e0       	ldi	r25, 0x00	; 0
 c00:	8c 0f       	add	r24, r28
 c02:	9d 1f       	adc	r25, r29
 c04:	81 0f       	add	r24, r17
 c06:	91 1d       	adc	r25, r1
 c08:	b4 c0       	rjmp	.+360    	; 0xd72 <uart_mini_printf+0x340>
 c0a:	fe 01       	movw	r30, r28
 c0c:	31 96       	adiw	r30, 0x01	; 1
                break;  // case 'd'
                
            case 'u':
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
 c0e:	71 92       	st	Z+, r7
                alt_p_c = FALSE;
                long_flag = FALSE;
                break;  // case 'd'
                
            case 'u':
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
 c10:	e4 15       	cp	r30, r4
 c12:	f5 05       	cpc	r31, r5
 c14:	e1 f7       	brne	.-8      	; 0xc0e <uart_mini_printf+0x1dc>
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
 c16:	1c 86       	std	Y+12, r1	; 0x0c
                data_idx = DATA_BUF_LEN - 2;
                if (long_flag)  // 32-bit
                {
                    u32_val = va_arg(arg_ptr, U32);
 c18:	58 01       	movw	r10, r16
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
                data_idx = DATA_BUF_LEN - 2;
                if (long_flag)  // 32-bit
 c1a:	99 23       	and	r25, r25
 c1c:	01 f1       	breq	.+64     	; 0xc5e <uart_mini_printf+0x22c>
                {
                    u32_val = va_arg(arg_ptr, U32);
 c1e:	f4 e0       	ldi	r31, 0x04	; 4
 c20:	af 0e       	add	r10, r31
 c22:	b1 1c       	adc	r11, r1
 c24:	f8 01       	movw	r30, r16
 c26:	60 81       	ld	r22, Z
 c28:	71 81       	ldd	r23, Z+1	; 0x01
 c2a:	82 81       	ldd	r24, Z+2	; 0x02
 c2c:	93 81       	ldd	r25, Z+3	; 0x03
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
                data_idx = DATA_BUF_LEN - 2;
 c2e:	ea e0       	ldi	r30, 0x0A	; 10
 c30:	3e 2e       	mov	r3, r30
                if (long_flag)  // 32-bit
                {
                    u32_val = va_arg(arg_ptr, U32);
                    while (1)
                    {
                        data_buf[data_idx] = u32_val % 10 + '0';
 c32:	01 e0       	ldi	r16, 0x01	; 1
 c34:	10 e0       	ldi	r17, 0x00	; 0
 c36:	0c 0f       	add	r16, r28
 c38:	1d 1f       	adc	r17, r29
 c3a:	03 0d       	add	r16, r3
 c3c:	11 1d       	adc	r17, r1
 c3e:	a7 01       	movw	r20, r14
 c40:	96 01       	movw	r18, r12
 c42:	0e 94 50 07 	call	0xea0	; 0xea0 <__udivmodsi4>
 c46:	60 5d       	subi	r22, 0xD0	; 208
 c48:	f8 01       	movw	r30, r16
 c4a:	60 83       	st	Z, r22
                        u32_val /= 10;
 c4c:	b9 01       	movw	r22, r18
 c4e:	ca 01       	movw	r24, r20
                        data_idx--;
 c50:	3a 94       	dec	r3
						if (u32_val==0) break;
 c52:	61 15       	cp	r22, r1
 c54:	71 05       	cpc	r23, r1
 c56:	81 05       	cpc	r24, r1
 c58:	91 05       	cpc	r25, r1
 c5a:	59 f7       	brne	.-42     	; 0xc32 <uart_mini_printf+0x200>
 c5c:	18 c0       	rjmp	.+48     	; 0xc8e <uart_mini_printf+0x25c>
                    }
                }
                else  // 16-bit
                {
                    u16_val = (U16)(va_arg(arg_ptr, int)); // u16_val = va_arg(arg_ptr, U16);
 c5e:	f2 e0       	ldi	r31, 0x02	; 2
 c60:	af 0e       	add	r10, r31
 c62:	b1 1c       	adc	r11, r1
 c64:	f8 01       	movw	r30, r16
 c66:	80 81       	ld	r24, Z
 c68:	91 81       	ldd	r25, Z+1	; 0x01
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
                data_idx = DATA_BUF_LEN - 2;
 c6a:	6a e0       	ldi	r22, 0x0A	; 10
 c6c:	36 2e       	mov	r3, r22
                else  // 16-bit
                {
                    u16_val = (U16)(va_arg(arg_ptr, int)); // u16_val = va_arg(arg_ptr, U16);
                    while (1)
                    {
                        data_buf[data_idx] = u16_val % 10 + '0';
 c6e:	e1 e0       	ldi	r30, 0x01	; 1
 c70:	f0 e0       	ldi	r31, 0x00	; 0
 c72:	ec 0f       	add	r30, r28
 c74:	fd 1f       	adc	r31, r29
 c76:	e3 0d       	add	r30, r3
 c78:	f1 1d       	adc	r31, r1
 c7a:	6a e0       	ldi	r22, 0x0A	; 10
 c7c:	70 e0       	ldi	r23, 0x00	; 0
 c7e:	0e 94 28 07 	call	0xe50	; 0xe50 <__udivmodhi4>
 c82:	80 5d       	subi	r24, 0xD0	; 208
 c84:	80 83       	st	Z, r24
                        data_idx--;
 c86:	3a 94       	dec	r3
                        u16_val /= 10;
 c88:	cb 01       	movw	r24, r22
						if (u16_val==0) break;
 c8a:	00 97       	sbiw	r24, 0x00	; 0
 c8c:	81 f7       	brne	.-32     	; 0xc6e <uart_mini_printf+0x23c>
                    }
                }
                data_idx++;
 c8e:	33 94       	inc	r3
 c90:	63 14       	cp	r6, r3
 c92:	08 f4       	brcc	.+2      	; 0xc96 <uart_mini_printf+0x264>
 c94:	36 2c       	mov	r3, r6
                if (min_size < data_idx)
                {
                    data_idx = min_size;
                }
                uart_put_string (data_buf + data_idx);
 c96:	81 e0       	ldi	r24, 0x01	; 1
 c98:	90 e0       	ldi	r25, 0x00	; 0
 c9a:	8c 0f       	add	r24, r28
 c9c:	9d 1f       	adc	r25, r29
 c9e:	83 0d       	add	r24, r3
 ca0:	91 1d       	adc	r25, r1
 ca2:	67 c0       	rjmp	.+206    	; 0xd72 <uart_mini_printf+0x340>
 ca4:	fe 01       	movw	r30, r28
 ca6:	31 96       	adiw	r30, 0x01	; 1
                
            case 'x':
            case 'X':
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
 ca8:	71 92       	st	Z+, r7
                long_flag = FALSE;
                break;  // case 'u':
                
            case 'x':
            case 'X':
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
 caa:	e4 15       	cp	r30, r4
 cac:	f5 05       	cpc	r31, r5
 cae:	e1 f7       	brne	.-8      	; 0xca8 <uart_mini_printf+0x276>
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
 cb0:	1c 86       	std	Y+12, r1	; 0x0c
                data_idx = DATA_BUF_LEN - 2;
                if (long_flag)  // 32-bit
                { 
                    u32_val = va_arg(arg_ptr, U32);
 cb2:	58 01       	movw	r10, r16
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
                data_idx = DATA_BUF_LEN - 2;
                if (long_flag)  // 32-bit
 cb4:	99 23       	and	r25, r25
 cb6:	69 f1       	breq	.+90     	; 0xd12 <uart_mini_printf+0x2e0>
                { 
                    u32_val = va_arg(arg_ptr, U32);
 cb8:	f4 e0       	ldi	r31, 0x04	; 4
 cba:	af 0e       	add	r10, r31
 cbc:	b1 1c       	adc	r11, r1
 cbe:	f8 01       	movw	r30, r16
 cc0:	80 81       	ld	r24, Z
 cc2:	91 81       	ldd	r25, Z+1	; 0x01
 cc4:	a2 81       	ldd	r26, Z+2	; 0x02
 cc6:	b3 81       	ldd	r27, Z+3	; 0x03
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
                data_idx = DATA_BUF_LEN - 2;
 cc8:	3a e0       	ldi	r19, 0x0A	; 10
                if (long_flag)  // 32-bit
                { 
                    u32_val = va_arg(arg_ptr, U32);
                    while (u32_val)
 cca:	00 97       	sbiw	r24, 0x00	; 0
 ccc:	a1 05       	cpc	r26, r1
 cce:	b1 05       	cpc	r27, r1
 cd0:	09 f4       	brne	.+2      	; 0xcd4 <uart_mini_printf+0x2a2>
 cd2:	45 c0       	rjmp	.+138    	; 0xd5e <uart_mini_printf+0x32c>
                    {
                        u8_temp = (U8)(u32_val & 0x0F);
 cd4:	48 2f       	mov	r20, r24
 cd6:	4f 70       	andi	r20, 0x0F	; 15
                        data_buf[data_idx] = (u8_temp < 10)? u8_temp+'0':u8_temp-10+(*p=='x'?'a':'A');
 cd8:	e3 2f       	mov	r30, r19
 cda:	f0 e0       	ldi	r31, 0x00	; 0
 cdc:	4a 30       	cpi	r20, 0x0A	; 10
 cde:	10 f4       	brcc	.+4      	; 0xce4 <uart_mini_printf+0x2b2>
 ce0:	40 5d       	subi	r20, 0xD0	; 208
 ce2:	07 c0       	rjmp	.+14     	; 0xcf2 <uart_mini_printf+0x2c0>
 ce4:	28 37       	cpi	r18, 0x78	; 120
 ce6:	11 f4       	brne	.+4      	; 0xcec <uart_mini_printf+0x2ba>
 ce8:	51 e6       	ldi	r21, 0x61	; 97
 cea:	01 c0       	rjmp	.+2      	; 0xcee <uart_mini_printf+0x2bc>
 cec:	51 e4       	ldi	r21, 0x41	; 65
 cee:	4a 50       	subi	r20, 0x0A	; 10
 cf0:	45 0f       	add	r20, r21
 cf2:	61 e0       	ldi	r22, 0x01	; 1
 cf4:	70 e0       	ldi	r23, 0x00	; 0
 cf6:	6c 0f       	add	r22, r28
 cf8:	7d 1f       	adc	r23, r29
 cfa:	e6 0f       	add	r30, r22
 cfc:	f7 1f       	adc	r31, r23
 cfe:	40 83       	st	Z, r20
                        u32_val >>= 4;
 d00:	54 e0       	ldi	r21, 0x04	; 4
 d02:	b6 95       	lsr	r27
 d04:	a7 95       	ror	r26
 d06:	97 95       	ror	r25
 d08:	87 95       	ror	r24
 d0a:	5a 95       	dec	r21
 d0c:	d1 f7       	brne	.-12     	; 0xd02 <uart_mini_printf+0x2d0>
                        data_idx--;
 d0e:	31 50       	subi	r19, 0x01	; 1
 d10:	dc cf       	rjmp	.-72     	; 0xcca <uart_mini_printf+0x298>
                    }
                }
                else  // 16-bit
                {
                    u16_val = (U16)(va_arg(arg_ptr, int)); // u16_val = va_arg(arg_ptr, U16);
 d12:	72 e0       	ldi	r23, 0x02	; 2
 d14:	a7 0e       	add	r10, r23
 d16:	b1 1c       	adc	r11, r1
 d18:	f8 01       	movw	r30, r16
 d1a:	80 81       	ld	r24, Z
 d1c:	91 81       	ldd	r25, Z+1	; 0x01
                for(data_idx = 0; data_idx < (DATA_BUF_LEN-1); data_idx++)
                {
                    data_buf[data_idx] = '0';
                }
                data_buf[DATA_BUF_LEN-1] = 0;
                data_idx = DATA_BUF_LEN - 2;
 d1e:	3a e0       	ldi	r19, 0x0A	; 10
                    }
                }
                else  // 16-bit
                {
                    u16_val = (U16)(va_arg(arg_ptr, int)); // u16_val = va_arg(arg_ptr, U16);
                    while (u16_val)
 d20:	00 97       	sbiw	r24, 0x00	; 0
 d22:	e9 f0       	breq	.+58     	; 0xd5e <uart_mini_printf+0x32c>
                    {
                        u8_temp = (U8)(u16_val & 0x0F);
 d24:	48 2f       	mov	r20, r24
 d26:	4f 70       	andi	r20, 0x0F	; 15
                        data_buf[data_idx] = (u8_temp < 10)? u8_temp+'0':u8_temp-10+(*p=='x'?'a':'A');
 d28:	e3 2f       	mov	r30, r19
 d2a:	f0 e0       	ldi	r31, 0x00	; 0
 d2c:	4a 30       	cpi	r20, 0x0A	; 10
 d2e:	10 f4       	brcc	.+4      	; 0xd34 <uart_mini_printf+0x302>
 d30:	40 5d       	subi	r20, 0xD0	; 208
 d32:	07 c0       	rjmp	.+14     	; 0xd42 <uart_mini_printf+0x310>
 d34:	28 37       	cpi	r18, 0x78	; 120
 d36:	11 f4       	brne	.+4      	; 0xd3c <uart_mini_printf+0x30a>
 d38:	51 e6       	ldi	r21, 0x61	; 97
 d3a:	01 c0       	rjmp	.+2      	; 0xd3e <uart_mini_printf+0x30c>
 d3c:	51 e4       	ldi	r21, 0x41	; 65
 d3e:	4a 50       	subi	r20, 0x0A	; 10
 d40:	45 0f       	add	r20, r21
 d42:	61 e0       	ldi	r22, 0x01	; 1
 d44:	70 e0       	ldi	r23, 0x00	; 0
 d46:	6c 0f       	add	r22, r28
 d48:	7d 1f       	adc	r23, r29
 d4a:	e6 0f       	add	r30, r22
 d4c:	f7 1f       	adc	r31, r23
 d4e:	40 83       	st	Z, r20
                        u16_val >>= 4;
 d50:	44 e0       	ldi	r20, 0x04	; 4
 d52:	96 95       	lsr	r25
 d54:	87 95       	ror	r24
 d56:	4a 95       	dec	r20
 d58:	e1 f7       	brne	.-8      	; 0xd52 <uart_mini_printf+0x320>
                        data_idx--;
 d5a:	31 50       	subi	r19, 0x01	; 1
 d5c:	e1 cf       	rjmp	.-62     	; 0xd20 <uart_mini_printf+0x2ee>
                    }
                }
                data_idx++;
 d5e:	3f 5f       	subi	r19, 0xFF	; 255
 d60:	63 16       	cp	r6, r19
 d62:	08 f4       	brcc	.+2      	; 0xd66 <uart_mini_printf+0x334>
 d64:	36 2d       	mov	r19, r6
                if (min_size < data_idx)
                {
                    data_idx = min_size;
                }
                uart_put_string (data_buf + data_idx);
 d66:	81 e0       	ldi	r24, 0x01	; 1
 d68:	90 e0       	ldi	r25, 0x00	; 0
 d6a:	8c 0f       	add	r24, r28
 d6c:	9d 1f       	adc	r25, r29
 d6e:	83 0f       	add	r24, r19
 d70:	91 1d       	adc	r25, r1
 d72:	0e 94 0d 05 	call	0xa1a	; 0xa1a <uart_put_string>
                // Clean up
                min_size = DATA_BUF_LEN-1;
                alt_p_c = FALSE;
                long_flag = FALSE;
                break;  // case 'x' & 'X'
 d76:	85 01       	movw	r16, r10
 d78:	45 c0       	rjmp	.+138    	; 0xe04 <uart_mini_printf+0x3d2>
                
            case '0':   // Max allowed "min_size" 2 decimal digit, truncated to DATA_BUF_LEN-1.
                min_size = DATA_BUF_LEN-1;
                if (long_flag == TRUE)      // ERROR: 'l' before '0'
 d7a:	91 30       	cpi	r25, 0x01	; 1
 d7c:	29 f4       	brne	.+10     	; 0xd88 <uart_mini_printf+0x356>
                {
                    uart_putchar('l');
 d7e:	8c e6       	ldi	r24, 0x6C	; 108
 d80:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                    uart_putchar('0');
 d84:	80 e3       	ldi	r24, 0x30	; 48
 d86:	3c c0       	rjmp	.+120    	; 0xe00 <uart_mini_printf+0x3ce>
                    // Clean up
                    alt_p_c = FALSE;
                    long_flag = FALSE;
                    break;
                }
                u8_temp = *++p;
 d88:	f5 01       	movw	r30, r10
 d8a:	82 81       	ldd	r24, Z+2	; 0x02
                if ((u8_temp >='0') && (u8_temp <='9'))
 d8c:	90 ed       	ldi	r25, 0xD0	; 208
 d8e:	98 0f       	add	r25, r24
 d90:	9a 30       	cpi	r25, 0x0A	; 10
 d92:	28 f5       	brcc	.+74     	; 0xdde <uart_mini_printf+0x3ac>
                {
                    min_size = u8_temp & 0x0F;
 d94:	8f 70       	andi	r24, 0x0F	; 15
                    u8_temp = *++p;
 d96:	93 81       	ldd	r25, Z+3	; 0x03
                    if ((u8_temp >='0') && (u8_temp <='9'))
 d98:	20 ed       	ldi	r18, 0xD0	; 208
 d9a:	29 0f       	add	r18, r25
 d9c:	2a 30       	cpi	r18, 0x0A	; 10
 d9e:	20 f0       	brcs	.+8      	; 0xda8 <uart_mini_printf+0x376>
                }
                u8_temp = *++p;
                if ((u8_temp >='0') && (u8_temp <='9'))
                {
                    min_size = u8_temp & 0x0F;
                    u8_temp = *++p;
 da0:	f3 e0       	ldi	r31, 0x03	; 3
 da2:	af 0e       	add	r10, r31
 da4:	b1 1c       	adc	r11, r1
 da6:	07 c0       	rjmp	.+14     	; 0xdb6 <uart_mini_printf+0x384>
                    if ((u8_temp >='0') && (u8_temp <='9'))
                    {
                        min_size <<= 4;
 da8:	82 95       	swap	r24
 daa:	80 7f       	andi	r24, 0xF0	; 240
                        min_size |= (u8_temp & 0x0F);
 dac:	9f 70       	andi	r25, 0x0F	; 15
 dae:	89 2b       	or	r24, r25
                        p++;
 db0:	24 e0       	ldi	r18, 0x04	; 4
 db2:	a2 0e       	add	r10, r18
 db4:	b1 1c       	adc	r11, r1
                    }
                    min_size = ((min_size & 0x0F) + ((min_size >> 4) *10));  // Decimal to hexa
 db6:	98 2f       	mov	r25, r24
 db8:	9f 70       	andi	r25, 0x0F	; 15
 dba:	82 95       	swap	r24
 dbc:	8f 70       	andi	r24, 0x0F	; 15
 dbe:	6a e0       	ldi	r22, 0x0A	; 10
 dc0:	86 9f       	mul	r24, r22
 dc2:	90 0d       	add	r25, r0
 dc4:	11 24       	eor	r1, r1
 dc6:	9c 30       	cpi	r25, 0x0C	; 12
 dc8:	08 f0       	brcs	.+2      	; 0xdcc <uart_mini_printf+0x39a>
 dca:	9b e0       	ldi	r25, 0x0B	; 11
                    if (min_size > (DATA_BUF_LEN-1))
                    {
                        min_size = (DATA_BUF_LEN-1);
                    }  // Truncation
                    min_size = DATA_BUF_LEN-1 - min_size;  // "min_size" formatted as "data_ix"
 dcc:	2b e0       	ldi	r18, 0x0B	; 11
 dce:	62 2e       	mov	r6, r18
 dd0:	69 1a       	sub	r6, r25
                    // Clean up
                    alt_p_c = FALSE;
                    long_flag = FALSE;
                    break;
                }
                p-=2;
 dd2:	45 01       	movw	r8, r10
 dd4:	72 e0       	ldi	r23, 0x02	; 2
 dd6:	87 1a       	sub	r8, r23
 dd8:	91 08       	sbc	r9, r1
                alt_p_c = TRUE;
 dda:	21 e0       	ldi	r18, 0x01	; 1
 ddc:	af ce       	rjmp	.-674    	; 0xb3c <uart_mini_printf+0x10a>
                    // Clean up
                    alt_p_c = FALSE;
                    long_flag = FALSE;
                    break;
                }
                u8_temp = *++p;
 dde:	45 01       	movw	r8, r10
 de0:	82 e0       	ldi	r24, 0x02	; 2
 de2:	88 0e       	add	r8, r24
 de4:	91 1c       	adc	r9, r1
                    }  // Truncation
                    min_size = DATA_BUF_LEN-1 - min_size;  // "min_size" formatted as "data_ix"
                }
                else      // ERROR: any "char" after '0'
                {
                    uart_putchar('0');
 de6:	80 e3       	ldi	r24, 0x30	; 48
 de8:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                    uart_putchar(*p);
 dec:	f5 01       	movw	r30, r10
 dee:	82 81       	ldd	r24, Z+2	; 0x02
 df0:	07 c0       	rjmp	.+14     	; 0xe00 <uart_mini_printf+0x3ce>
                // Clean up
                long_flag = FALSE;
                break;  // case '0'
                
            default:
                if (long_flag == TRUE)
 df2:	91 30       	cpi	r25, 0x01	; 1
 df4:	19 f4       	brne	.+6      	; 0xdfc <uart_mini_printf+0x3ca>
                {
                    uart_putchar('l');
 df6:	8c e6       	ldi	r24, 0x6C	; 108
 df8:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                }
                uart_putchar(*p);
 dfc:	f5 01       	movw	r30, r10
 dfe:	81 81       	ldd	r24, Z+1	; 0x01
 e00:	0e 94 06 05 	call	0xa0c	; 0xa0c <uart_putchar>
                // Clean up
                min_size = DATA_BUF_LEN-1;
                alt_p_c = FALSE;
 e04:	20 e0       	ldi	r18, 0x00	; 0
                long_flag = FALSE;
 e06:	90 e0       	ldi	r25, 0x00	; 0
                {
                    uart_putchar('l');
                }
                uart_putchar(*p);
                // Clean up
                min_size = DATA_BUF_LEN-1;
 e08:	8b e0       	ldi	r24, 0x0B	; 11
 e0a:	68 2e       	mov	r6, r24
                alt_p_c = FALSE;
                long_flag = FALSE;
                break;  // default
 e0c:	03 c0       	rjmp	.+6      	; 0xe14 <uart_mini_printf+0x3e2>
                else
                {
                    alt_p_c = TRUE;
                    long_flag = TRUE;
                }
                p--;
 e0e:	45 01       	movw	r8, r10
                    long_flag = FALSE;
                }
                else
                {
                    alt_p_c = TRUE;
                    long_flag = TRUE;
 e10:	21 e0       	ldi	r18, 0x01	; 1
 e12:	91 e0       	ldi	r25, 0x01	; 1
    long_flag = FALSE;
    alt_p_c = FALSE;
    min_size = DATA_BUF_LEN-1;

    va_start(arg_ptr, format);   // make arg_ptr point to the first unnamed arg
    for (p = (U8 *) format; *p; p++)
 e14:	54 01       	movw	r10, r8
 e16:	ff ef       	ldi	r31, 0xFF	; 255
 e18:	af 1a       	sub	r10, r31
 e1a:	bf 0a       	sbc	r11, r31
 e1c:	38 ce       	rjmp	.-912    	; 0xa8e <uart_mini_printf+0x5c>
        
    }   // for (p = ...
    
    va_end(arg_ptr);
    return 0;
}
 e1e:	2c 96       	adiw	r28, 0x0c	; 12
 e20:	0f b6       	in	r0, 0x3f	; 63
 e22:	f8 94       	cli
 e24:	de bf       	out	0x3e, r29	; 62
 e26:	0f be       	out	0x3f, r0	; 63
 e28:	cd bf       	out	0x3d, r28	; 61
 e2a:	df 91       	pop	r29
 e2c:	cf 91       	pop	r28
 e2e:	1f 91       	pop	r17
 e30:	0f 91       	pop	r16
 e32:	ff 90       	pop	r15
 e34:	ef 90       	pop	r14
 e36:	df 90       	pop	r13
 e38:	cf 90       	pop	r12
 e3a:	bf 90       	pop	r11
 e3c:	af 90       	pop	r10
 e3e:	9f 90       	pop	r9
 e40:	8f 90       	pop	r8
 e42:	7f 90       	pop	r7
 e44:	6f 90       	pop	r6
 e46:	5f 90       	pop	r5
 e48:	4f 90       	pop	r4
 e4a:	3f 90       	pop	r3
 e4c:	2f 90       	pop	r2
 e4e:	08 95       	ret

00000e50 <__udivmodhi4>:
 e50:	aa 1b       	sub	r26, r26
 e52:	bb 1b       	sub	r27, r27
 e54:	51 e1       	ldi	r21, 0x11	; 17
 e56:	07 c0       	rjmp	.+14     	; 0xe66 <__udivmodhi4_ep>

00000e58 <__udivmodhi4_loop>:
 e58:	aa 1f       	adc	r26, r26
 e5a:	bb 1f       	adc	r27, r27
 e5c:	a6 17       	cp	r26, r22
 e5e:	b7 07       	cpc	r27, r23
 e60:	10 f0       	brcs	.+4      	; 0xe66 <__udivmodhi4_ep>
 e62:	a6 1b       	sub	r26, r22
 e64:	b7 0b       	sbc	r27, r23

00000e66 <__udivmodhi4_ep>:
 e66:	88 1f       	adc	r24, r24
 e68:	99 1f       	adc	r25, r25
 e6a:	5a 95       	dec	r21
 e6c:	a9 f7       	brne	.-22     	; 0xe58 <__udivmodhi4_loop>
 e6e:	80 95       	com	r24
 e70:	90 95       	com	r25
 e72:	bc 01       	movw	r22, r24
 e74:	cd 01       	movw	r24, r26
 e76:	08 95       	ret

00000e78 <__divmodhi4>:
 e78:	97 fb       	bst	r25, 7
 e7a:	07 2e       	mov	r0, r23
 e7c:	16 f4       	brtc	.+4      	; 0xe82 <__divmodhi4+0xa>
 e7e:	00 94       	com	r0
 e80:	07 d0       	rcall	.+14     	; 0xe90 <__divmodhi4_neg1>
 e82:	77 fd       	sbrc	r23, 7
 e84:	09 d0       	rcall	.+18     	; 0xe98 <__divmodhi4_neg2>
 e86:	0e 94 28 07 	call	0xe50	; 0xe50 <__udivmodhi4>
 e8a:	07 fc       	sbrc	r0, 7
 e8c:	05 d0       	rcall	.+10     	; 0xe98 <__divmodhi4_neg2>
 e8e:	3e f4       	brtc	.+14     	; 0xe9e <__divmodhi4_exit>

00000e90 <__divmodhi4_neg1>:
 e90:	90 95       	com	r25
 e92:	81 95       	neg	r24
 e94:	9f 4f       	sbci	r25, 0xFF	; 255
 e96:	08 95       	ret

00000e98 <__divmodhi4_neg2>:
 e98:	70 95       	com	r23
 e9a:	61 95       	neg	r22
 e9c:	7f 4f       	sbci	r23, 0xFF	; 255

00000e9e <__divmodhi4_exit>:
 e9e:	08 95       	ret

00000ea0 <__udivmodsi4>:
 ea0:	a1 e2       	ldi	r26, 0x21	; 33
 ea2:	1a 2e       	mov	r1, r26
 ea4:	aa 1b       	sub	r26, r26
 ea6:	bb 1b       	sub	r27, r27
 ea8:	fd 01       	movw	r30, r26
 eaa:	0d c0       	rjmp	.+26     	; 0xec6 <__udivmodsi4_ep>

00000eac <__udivmodsi4_loop>:
 eac:	aa 1f       	adc	r26, r26
 eae:	bb 1f       	adc	r27, r27
 eb0:	ee 1f       	adc	r30, r30
 eb2:	ff 1f       	adc	r31, r31
 eb4:	a2 17       	cp	r26, r18
 eb6:	b3 07       	cpc	r27, r19
 eb8:	e4 07       	cpc	r30, r20
 eba:	f5 07       	cpc	r31, r21
 ebc:	20 f0       	brcs	.+8      	; 0xec6 <__udivmodsi4_ep>
 ebe:	a2 1b       	sub	r26, r18
 ec0:	b3 0b       	sbc	r27, r19
 ec2:	e4 0b       	sbc	r30, r20
 ec4:	f5 0b       	sbc	r31, r21

00000ec6 <__udivmodsi4_ep>:
 ec6:	66 1f       	adc	r22, r22
 ec8:	77 1f       	adc	r23, r23
 eca:	88 1f       	adc	r24, r24
 ecc:	99 1f       	adc	r25, r25
 ece:	1a 94       	dec	r1
 ed0:	69 f7       	brne	.-38     	; 0xeac <__udivmodsi4_loop>
 ed2:	60 95       	com	r22
 ed4:	70 95       	com	r23
 ed6:	80 95       	com	r24
 ed8:	90 95       	com	r25
 eda:	9b 01       	movw	r18, r22
 edc:	ac 01       	movw	r20, r24
 ede:	bd 01       	movw	r22, r26
 ee0:	cf 01       	movw	r24, r30
 ee2:	08 95       	ret

00000ee4 <__divmodsi4>:
 ee4:	05 2e       	mov	r0, r21
 ee6:	97 fb       	bst	r25, 7
 ee8:	1e f4       	brtc	.+6      	; 0xef0 <__divmodsi4+0xc>
 eea:	00 94       	com	r0
 eec:	0e 94 89 07 	call	0xf12	; 0xf12 <__negsi2>
 ef0:	57 fd       	sbrc	r21, 7
 ef2:	07 d0       	rcall	.+14     	; 0xf02 <__divmodsi4_neg2>
 ef4:	0e 94 50 07 	call	0xea0	; 0xea0 <__udivmodsi4>
 ef8:	07 fc       	sbrc	r0, 7
 efa:	03 d0       	rcall	.+6      	; 0xf02 <__divmodsi4_neg2>
 efc:	4e f4       	brtc	.+18     	; 0xf10 <__divmodsi4_exit>
 efe:	0c 94 89 07 	jmp	0xf12	; 0xf12 <__negsi2>

00000f02 <__divmodsi4_neg2>:
 f02:	50 95       	com	r21
 f04:	40 95       	com	r20
 f06:	30 95       	com	r19
 f08:	21 95       	neg	r18
 f0a:	3f 4f       	sbci	r19, 0xFF	; 255
 f0c:	4f 4f       	sbci	r20, 0xFF	; 255
 f0e:	5f 4f       	sbci	r21, 0xFF	; 255

00000f10 <__divmodsi4_exit>:
 f10:	08 95       	ret

00000f12 <__negsi2>:
 f12:	90 95       	com	r25
 f14:	80 95       	com	r24
 f16:	70 95       	com	r23
 f18:	61 95       	neg	r22
 f1a:	7f 4f       	sbci	r23, 0xFF	; 255
 f1c:	8f 4f       	sbci	r24, 0xFF	; 255
 f1e:	9f 4f       	sbci	r25, 0xFF	; 255
 f20:	08 95       	ret

00000f22 <_exit>:
 f22:	f8 94       	cli

00000f24 <__stop_program>:
 f24:	ff cf       	rjmp	.-2      	; 0xf24 <__stop_program>
